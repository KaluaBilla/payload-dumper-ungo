// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: update_metadata.proto
// Protobuf C++ Version: 5.29.3

#ifndef update_5fmetadata_2eproto_2epb_2eh
#define update_5fmetadata_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_update_5fmetadata_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_update_5fmetadata_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_update_5fmetadata_2eproto;
namespace chromeos_update_engine {
class ApexInfo;
struct ApexInfoDefaultTypeInternal;
extern ApexInfoDefaultTypeInternal _ApexInfo_default_instance_;
class ApexMetadata;
struct ApexMetadataDefaultTypeInternal;
extern ApexMetadataDefaultTypeInternal _ApexMetadata_default_instance_;
class CowMergeOperation;
struct CowMergeOperationDefaultTypeInternal;
extern CowMergeOperationDefaultTypeInternal _CowMergeOperation_default_instance_;
class DeltaArchiveManifest;
struct DeltaArchiveManifestDefaultTypeInternal;
extern DeltaArchiveManifestDefaultTypeInternal _DeltaArchiveManifest_default_instance_;
class DynamicPartitionGroup;
struct DynamicPartitionGroupDefaultTypeInternal;
extern DynamicPartitionGroupDefaultTypeInternal _DynamicPartitionGroup_default_instance_;
class DynamicPartitionMetadata;
struct DynamicPartitionMetadataDefaultTypeInternal;
extern DynamicPartitionMetadataDefaultTypeInternal _DynamicPartitionMetadata_default_instance_;
class Extent;
struct ExtentDefaultTypeInternal;
extern ExtentDefaultTypeInternal _Extent_default_instance_;
class InstallOperation;
struct InstallOperationDefaultTypeInternal;
extern InstallOperationDefaultTypeInternal _InstallOperation_default_instance_;
class PartitionInfo;
struct PartitionInfoDefaultTypeInternal;
extern PartitionInfoDefaultTypeInternal _PartitionInfo_default_instance_;
class PartitionUpdate;
struct PartitionUpdateDefaultTypeInternal;
extern PartitionUpdateDefaultTypeInternal _PartitionUpdate_default_instance_;
class Signatures;
struct SignaturesDefaultTypeInternal;
extern SignaturesDefaultTypeInternal _Signatures_default_instance_;
class Signatures_Signature;
struct Signatures_SignatureDefaultTypeInternal;
extern Signatures_SignatureDefaultTypeInternal _Signatures_Signature_default_instance_;
class VABCFeatureSet;
struct VABCFeatureSetDefaultTypeInternal;
extern VABCFeatureSetDefaultTypeInternal _VABCFeatureSet_default_instance_;
}  // namespace chromeos_update_engine
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace chromeos_update_engine {
enum InstallOperation_Type : int {
  InstallOperation_Type_REPLACE = 0,
  InstallOperation_Type_REPLACE_BZ = 1,
  InstallOperation_Type_MOVE [[deprecated]] = 2,
  InstallOperation_Type_BSDIFF [[deprecated]] = 3,
  InstallOperation_Type_SOURCE_COPY = 4,
  InstallOperation_Type_SOURCE_BSDIFF = 5,
  InstallOperation_Type_REPLACE_XZ = 8,
  InstallOperation_Type_ZERO = 6,
  InstallOperation_Type_DISCARD = 7,
  InstallOperation_Type_BROTLI_BSDIFF = 10,
  InstallOperation_Type_PUFFDIFF = 9,
  InstallOperation_Type_ZUCCHINI = 11,
  InstallOperation_Type_LZ4DIFF_BSDIFF = 12,
  InstallOperation_Type_LZ4DIFF_PUFFDIFF = 13,
  InstallOperation_Type_ZSTD = 14,
};

bool InstallOperation_Type_IsValid(int value);
extern const uint32_t InstallOperation_Type_internal_data_[];
constexpr InstallOperation_Type InstallOperation_Type_Type_MIN = static_cast<InstallOperation_Type>(0);
constexpr InstallOperation_Type InstallOperation_Type_Type_MAX = static_cast<InstallOperation_Type>(14);
constexpr int InstallOperation_Type_Type_ARRAYSIZE = 14 + 1;
const ::google::protobuf::EnumDescriptor*
InstallOperation_Type_descriptor();
template <typename T>
const std::string& InstallOperation_Type_Name(T value) {
  static_assert(std::is_same<T, InstallOperation_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return InstallOperation_Type_Name(static_cast<InstallOperation_Type>(value));
}
template <>
inline const std::string& InstallOperation_Type_Name(InstallOperation_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<InstallOperation_Type_descriptor,
                                                 0, 14>(
      static_cast<int>(value));
}
inline bool InstallOperation_Type_Parse(absl::string_view name, InstallOperation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InstallOperation_Type>(
      InstallOperation_Type_descriptor(), name, value);
}
enum CowMergeOperation_Type : int {
  CowMergeOperation_Type_COW_COPY = 0,
  CowMergeOperation_Type_COW_XOR = 1,
  CowMergeOperation_Type_COW_REPLACE = 2,
};

bool CowMergeOperation_Type_IsValid(int value);
extern const uint32_t CowMergeOperation_Type_internal_data_[];
constexpr CowMergeOperation_Type CowMergeOperation_Type_Type_MIN = static_cast<CowMergeOperation_Type>(0);
constexpr CowMergeOperation_Type CowMergeOperation_Type_Type_MAX = static_cast<CowMergeOperation_Type>(2);
constexpr int CowMergeOperation_Type_Type_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
CowMergeOperation_Type_descriptor();
template <typename T>
const std::string& CowMergeOperation_Type_Name(T value) {
  static_assert(std::is_same<T, CowMergeOperation_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return CowMergeOperation_Type_Name(static_cast<CowMergeOperation_Type>(value));
}
template <>
inline const std::string& CowMergeOperation_Type_Name(CowMergeOperation_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CowMergeOperation_Type_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool CowMergeOperation_Type_Parse(absl::string_view name, CowMergeOperation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CowMergeOperation_Type>(
      CowMergeOperation_Type_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class VABCFeatureSet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:chromeos_update_engine.VABCFeatureSet) */ {
 public:
  inline VABCFeatureSet() : VABCFeatureSet(nullptr) {}
  ~VABCFeatureSet() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VABCFeatureSet* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VABCFeatureSet));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VABCFeatureSet(
      ::google::protobuf::internal::ConstantInitialized);

  inline VABCFeatureSet(const VABCFeatureSet& from) : VABCFeatureSet(nullptr, from) {}
  inline VABCFeatureSet(VABCFeatureSet&& from) noexcept
      : VABCFeatureSet(nullptr, std::move(from)) {}
  inline VABCFeatureSet& operator=(const VABCFeatureSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline VABCFeatureSet& operator=(VABCFeatureSet&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VABCFeatureSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const VABCFeatureSet* internal_default_instance() {
    return reinterpret_cast<const VABCFeatureSet*>(
        &_VABCFeatureSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(VABCFeatureSet& a, VABCFeatureSet& b) { a.Swap(&b); }
  inline void Swap(VABCFeatureSet* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VABCFeatureSet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VABCFeatureSet* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VABCFeatureSet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VABCFeatureSet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VABCFeatureSet& from) { VABCFeatureSet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VABCFeatureSet* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "chromeos_update_engine.VABCFeatureSet"; }

 protected:
  explicit VABCFeatureSet(::google::protobuf::Arena* arena);
  VABCFeatureSet(::google::protobuf::Arena* arena, const VABCFeatureSet& from);
  VABCFeatureSet(::google::protobuf::Arena* arena, VABCFeatureSet&& from) noexcept
      : VABCFeatureSet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kThreadedFieldNumber = 1,
    kBatchWritesFieldNumber = 2,
  };
  // optional bool threaded = 1;
  bool has_threaded() const;
  void clear_threaded() ;
  bool threaded() const;
  void set_threaded(bool value);

  private:
  bool _internal_threaded() const;
  void _internal_set_threaded(bool value);

  public:
  // optional bool batch_writes = 2;
  bool has_batch_writes() const;
  void clear_batch_writes() ;
  bool batch_writes() const;
  void set_batch_writes(bool value);

  private:
  bool _internal_batch_writes() const;
  void _internal_set_batch_writes(bool value);

  public:
  // @@protoc_insertion_point(class_scope:chromeos_update_engine.VABCFeatureSet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VABCFeatureSet& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    bool threaded_;
    bool batch_writes_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class Signatures_Signature final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:chromeos_update_engine.Signatures.Signature) */ {
 public:
  inline Signatures_Signature() : Signatures_Signature(nullptr) {}
  ~Signatures_Signature() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Signatures_Signature* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Signatures_Signature));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Signatures_Signature(
      ::google::protobuf::internal::ConstantInitialized);

  inline Signatures_Signature(const Signatures_Signature& from) : Signatures_Signature(nullptr, from) {}
  inline Signatures_Signature(Signatures_Signature&& from) noexcept
      : Signatures_Signature(nullptr, std::move(from)) {}
  inline Signatures_Signature& operator=(const Signatures_Signature& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signatures_Signature& operator=(Signatures_Signature&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Signatures_Signature& default_instance() {
    return *internal_default_instance();
  }
  static inline const Signatures_Signature* internal_default_instance() {
    return reinterpret_cast<const Signatures_Signature*>(
        &_Signatures_Signature_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Signatures_Signature& a, Signatures_Signature& b) { a.Swap(&b); }
  inline void Swap(Signatures_Signature* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signatures_Signature* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Signatures_Signature* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Signatures_Signature>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Signatures_Signature& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Signatures_Signature& from) { Signatures_Signature::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Signatures_Signature* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "chromeos_update_engine.Signatures.Signature"; }

 protected:
  explicit Signatures_Signature(::google::protobuf::Arena* arena);
  Signatures_Signature(::google::protobuf::Arena* arena, const Signatures_Signature& from);
  Signatures_Signature(::google::protobuf::Arena* arena, Signatures_Signature&& from) noexcept
      : Signatures_Signature(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 2,
    kVersionFieldNumber = 1,
    kUnpaddedSignatureSizeFieldNumber = 3,
  };
  // optional bytes data = 2;
  bool has_data() const;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // optional uint32 version = 1 [deprecated = true];
  [[deprecated]]  bool has_version() const;
  [[deprecated]]  void clear_version() ;
  [[deprecated]] ::uint32_t version() const;
  [[deprecated]] void set_version(::uint32_t value);

  private:
  ::uint32_t _internal_version() const;
  void _internal_set_version(::uint32_t value);

  public:
  // optional fixed32 unpadded_signature_size = 3;
  bool has_unpadded_signature_size() const;
  void clear_unpadded_signature_size() ;
  ::uint32_t unpadded_signature_size() const;
  void set_unpadded_signature_size(::uint32_t value);

  private:
  ::uint32_t _internal_unpadded_signature_size() const;
  void _internal_set_unpadded_signature_size(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures.Signature)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Signatures_Signature& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::uint32_t version_;
    ::uint32_t unpadded_signature_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class PartitionInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:chromeos_update_engine.PartitionInfo) */ {
 public:
  inline PartitionInfo() : PartitionInfo(nullptr) {}
  ~PartitionInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PartitionInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PartitionInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PartitionInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline PartitionInfo(const PartitionInfo& from) : PartitionInfo(nullptr, from) {}
  inline PartitionInfo(PartitionInfo&& from) noexcept
      : PartitionInfo(nullptr, std::move(from)) {}
  inline PartitionInfo& operator=(const PartitionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionInfo& operator=(PartitionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionInfo* internal_default_instance() {
    return reinterpret_cast<const PartitionInfo*>(
        &_PartitionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(PartitionInfo& a, PartitionInfo& b) { a.Swap(&b); }
  inline void Swap(PartitionInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitionInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PartitionInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PartitionInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PartitionInfo& from) { PartitionInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PartitionInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "chromeos_update_engine.PartitionInfo"; }

 protected:
  explicit PartitionInfo(::google::protobuf::Arena* arena);
  PartitionInfo(::google::protobuf::Arena* arena, const PartitionInfo& from);
  PartitionInfo(::google::protobuf::Arena* arena, PartitionInfo&& from) noexcept
      : PartitionInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHashFieldNumber = 2,
    kSizeFieldNumber = 1,
  };
  // optional bytes hash = 2;
  bool has_hash() const;
  void clear_hash() ;
  const std::string& hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* value);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // optional uint64 size = 1;
  bool has_size() const;
  void clear_size() ;
  ::uint64_t size() const;
  void set_size(::uint64_t value);

  private:
  ::uint64_t _internal_size() const;
  void _internal_set_size(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PartitionInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr hash_;
    ::uint64_t size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class Extent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:chromeos_update_engine.Extent) */ {
 public:
  inline Extent() : Extent(nullptr) {}
  ~Extent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Extent* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Extent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Extent(
      ::google::protobuf::internal::ConstantInitialized);

  inline Extent(const Extent& from) : Extent(nullptr, from) {}
  inline Extent(Extent&& from) noexcept
      : Extent(nullptr, std::move(from)) {}
  inline Extent& operator=(const Extent& from) {
    CopyFrom(from);
    return *this;
  }
  inline Extent& operator=(Extent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Extent& default_instance() {
    return *internal_default_instance();
  }
  static inline const Extent* internal_default_instance() {
    return reinterpret_cast<const Extent*>(
        &_Extent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Extent& a, Extent& b) { a.Swap(&b); }
  inline void Swap(Extent* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Extent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Extent* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Extent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Extent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Extent& from) { Extent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Extent* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "chromeos_update_engine.Extent"; }

 protected:
  explicit Extent(::google::protobuf::Arena* arena);
  Extent(::google::protobuf::Arena* arena, const Extent& from);
  Extent(::google::protobuf::Arena* arena, Extent&& from) noexcept
      : Extent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStartBlockFieldNumber = 1,
    kNumBlocksFieldNumber = 2,
  };
  // optional uint64 start_block = 1;
  bool has_start_block() const;
  void clear_start_block() ;
  ::uint64_t start_block() const;
  void set_start_block(::uint64_t value);

  private:
  ::uint64_t _internal_start_block() const;
  void _internal_set_start_block(::uint64_t value);

  public:
  // optional uint64 num_blocks = 2;
  bool has_num_blocks() const;
  void clear_num_blocks() ;
  ::uint64_t num_blocks() const;
  void set_num_blocks(::uint64_t value);

  private:
  ::uint64_t _internal_num_blocks() const;
  void _internal_set_num_blocks(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Extent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t start_block_;
    ::uint64_t num_blocks_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class DynamicPartitionGroup final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:chromeos_update_engine.DynamicPartitionGroup) */ {
 public:
  inline DynamicPartitionGroup() : DynamicPartitionGroup(nullptr) {}
  ~DynamicPartitionGroup() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DynamicPartitionGroup* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DynamicPartitionGroup));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DynamicPartitionGroup(
      ::google::protobuf::internal::ConstantInitialized);

  inline DynamicPartitionGroup(const DynamicPartitionGroup& from) : DynamicPartitionGroup(nullptr, from) {}
  inline DynamicPartitionGroup(DynamicPartitionGroup&& from) noexcept
      : DynamicPartitionGroup(nullptr, std::move(from)) {}
  inline DynamicPartitionGroup& operator=(const DynamicPartitionGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline DynamicPartitionGroup& operator=(DynamicPartitionGroup&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DynamicPartitionGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const DynamicPartitionGroup* internal_default_instance() {
    return reinterpret_cast<const DynamicPartitionGroup*>(
        &_DynamicPartitionGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(DynamicPartitionGroup& a, DynamicPartitionGroup& b) { a.Swap(&b); }
  inline void Swap(DynamicPartitionGroup* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DynamicPartitionGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DynamicPartitionGroup* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DynamicPartitionGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DynamicPartitionGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DynamicPartitionGroup& from) { DynamicPartitionGroup::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DynamicPartitionGroup* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "chromeos_update_engine.DynamicPartitionGroup"; }

 protected:
  explicit DynamicPartitionGroup(::google::protobuf::Arena* arena);
  DynamicPartitionGroup(::google::protobuf::Arena* arena, const DynamicPartitionGroup& from);
  DynamicPartitionGroup(::google::protobuf::Arena* arena, DynamicPartitionGroup&& from) noexcept
      : DynamicPartitionGroup(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPartitionNamesFieldNumber = 3,
    kNameFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // repeated string partition_names = 3;
  int partition_names_size() const;
  private:
  int _internal_partition_names_size() const;

  public:
  void clear_partition_names() ;
  const std::string& partition_names(int index) const;
  std::string* mutable_partition_names(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_partition_names(int index, Arg_&& value, Args_... args);
  std::string* add_partition_names();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_partition_names(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& partition_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_partition_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_partition_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_partition_names();

  public:
  // required string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional uint64 size = 2;
  bool has_size() const;
  void clear_size() ;
  ::uint64_t size() const;
  void set_size(::uint64_t value);

  private:
  ::uint64_t _internal_size() const;
  void _internal_set_size(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionGroup)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      72, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DynamicPartitionGroup& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> partition_names_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint64_t size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ApexInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:chromeos_update_engine.ApexInfo) */ {
 public:
  inline ApexInfo() : ApexInfo(nullptr) {}
  ~ApexInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ApexInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ApexInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApexInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline ApexInfo(const ApexInfo& from) : ApexInfo(nullptr, from) {}
  inline ApexInfo(ApexInfo&& from) noexcept
      : ApexInfo(nullptr, std::move(from)) {}
  inline ApexInfo& operator=(const ApexInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApexInfo& operator=(ApexInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApexInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApexInfo* internal_default_instance() {
    return reinterpret_cast<const ApexInfo*>(
        &_ApexInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ApexInfo& a, ApexInfo& b) { a.Swap(&b); }
  inline void Swap(ApexInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApexInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApexInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ApexInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ApexInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ApexInfo& from) { ApexInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ApexInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "chromeos_update_engine.ApexInfo"; }

 protected:
  explicit ApexInfo(::google::protobuf::Arena* arena);
  ApexInfo(::google::protobuf::Arena* arena, const ApexInfo& from);
  ApexInfo(::google::protobuf::Arena* arena, ApexInfo&& from) noexcept
      : ApexInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPackageNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kDecompressedSizeFieldNumber = 4,
    kIsCompressedFieldNumber = 3,
  };
  // optional string package_name = 1;
  bool has_package_name() const;
  void clear_package_name() ;
  const std::string& package_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_package_name(Arg_&& arg, Args_... args);
  std::string* mutable_package_name();
  PROTOBUF_NODISCARD std::string* release_package_name();
  void set_allocated_package_name(std::string* value);

  private:
  const std::string& _internal_package_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_name(
      const std::string& value);
  std::string* _internal_mutable_package_name();

  public:
  // optional int64 version = 2;
  bool has_version() const;
  void clear_version() ;
  ::int64_t version() const;
  void set_version(::int64_t value);

  private:
  ::int64_t _internal_version() const;
  void _internal_set_version(::int64_t value);

  public:
  // optional int64 decompressed_size = 4;
  bool has_decompressed_size() const;
  void clear_decompressed_size() ;
  ::int64_t decompressed_size() const;
  void set_decompressed_size(::int64_t value);

  private:
  ::int64_t _internal_decompressed_size() const;
  void _internal_set_decompressed_size(::int64_t value);

  public:
  // optional bool is_compressed = 3;
  bool has_is_compressed() const;
  void clear_is_compressed() ;
  bool is_compressed() const;
  void set_is_compressed(bool value);

  private:
  bool _internal_is_compressed() const;
  void _internal_set_is_compressed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:chromeos_update_engine.ApexInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      52, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ApexInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr package_name_;
    ::int64_t version_;
    ::int64_t decompressed_size_;
    bool is_compressed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class Signatures final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:chromeos_update_engine.Signatures) */ {
 public:
  inline Signatures() : Signatures(nullptr) {}
  ~Signatures() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Signatures* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Signatures));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Signatures(
      ::google::protobuf::internal::ConstantInitialized);

  inline Signatures(const Signatures& from) : Signatures(nullptr, from) {}
  inline Signatures(Signatures&& from) noexcept
      : Signatures(nullptr, std::move(from)) {}
  inline Signatures& operator=(const Signatures& from) {
    CopyFrom(from);
    return *this;
  }
  inline Signatures& operator=(Signatures&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Signatures& default_instance() {
    return *internal_default_instance();
  }
  static inline const Signatures* internal_default_instance() {
    return reinterpret_cast<const Signatures*>(
        &_Signatures_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Signatures& a, Signatures& b) { a.Swap(&b); }
  inline void Swap(Signatures* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Signatures* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Signatures* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Signatures>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Signatures& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Signatures& from) { Signatures::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Signatures* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "chromeos_update_engine.Signatures"; }

 protected:
  explicit Signatures(::google::protobuf::Arena* arena);
  Signatures(::google::protobuf::Arena* arena, const Signatures& from);
  Signatures(::google::protobuf::Arena* arena, Signatures&& from) noexcept
      : Signatures(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Signature = Signatures_Signature;

  // accessors -------------------------------------------------------
  enum : int {
    kSignaturesFieldNumber = 1,
  };
  // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
  int signatures_size() const;
  private:
  int _internal_signatures_size() const;

  public:
  void clear_signatures() ;
  ::chromeos_update_engine::Signatures_Signature* mutable_signatures(int index);
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>* mutable_signatures();

  private:
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>& _internal_signatures() const;
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>* _internal_mutable_signatures();
  public:
  const ::chromeos_update_engine::Signatures_Signature& signatures(int index) const;
  ::chromeos_update_engine::Signatures_Signature* add_signatures();
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>& signatures() const;
  // @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Signatures& from_msg);
    ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature > signatures_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class InstallOperation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:chromeos_update_engine.InstallOperation) */ {
 public:
  inline InstallOperation() : InstallOperation(nullptr) {}
  ~InstallOperation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InstallOperation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InstallOperation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InstallOperation(
      ::google::protobuf::internal::ConstantInitialized);

  inline InstallOperation(const InstallOperation& from) : InstallOperation(nullptr, from) {}
  inline InstallOperation(InstallOperation&& from) noexcept
      : InstallOperation(nullptr, std::move(from)) {}
  inline InstallOperation& operator=(const InstallOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallOperation& operator=(InstallOperation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstallOperation& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallOperation* internal_default_instance() {
    return reinterpret_cast<const InstallOperation*>(
        &_InstallOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(InstallOperation& a, InstallOperation& b) { a.Swap(&b); }
  inline void Swap(InstallOperation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallOperation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallOperation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InstallOperation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InstallOperation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InstallOperation& from) { InstallOperation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InstallOperation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "chromeos_update_engine.InstallOperation"; }

 protected:
  explicit InstallOperation(::google::protobuf::Arena* arena);
  InstallOperation(::google::protobuf::Arena* arena, const InstallOperation& from);
  InstallOperation(::google::protobuf::Arena* arena, InstallOperation&& from) noexcept
      : InstallOperation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = InstallOperation_Type;
  static constexpr Type REPLACE = InstallOperation_Type_REPLACE;
  static constexpr Type REPLACE_BZ = InstallOperation_Type_REPLACE_BZ;
  [[deprecated]] static constexpr Type MOVE = InstallOperation_Type_MOVE;
  [[deprecated]] static constexpr Type BSDIFF = InstallOperation_Type_BSDIFF;
  static constexpr Type SOURCE_COPY = InstallOperation_Type_SOURCE_COPY;
  static constexpr Type SOURCE_BSDIFF = InstallOperation_Type_SOURCE_BSDIFF;
  static constexpr Type REPLACE_XZ = InstallOperation_Type_REPLACE_XZ;
  static constexpr Type ZERO = InstallOperation_Type_ZERO;
  static constexpr Type DISCARD = InstallOperation_Type_DISCARD;
  static constexpr Type BROTLI_BSDIFF = InstallOperation_Type_BROTLI_BSDIFF;
  static constexpr Type PUFFDIFF = InstallOperation_Type_PUFFDIFF;
  static constexpr Type ZUCCHINI = InstallOperation_Type_ZUCCHINI;
  static constexpr Type LZ4DIFF_BSDIFF = InstallOperation_Type_LZ4DIFF_BSDIFF;
  static constexpr Type LZ4DIFF_PUFFDIFF = InstallOperation_Type_LZ4DIFF_PUFFDIFF;
  static constexpr Type ZSTD = InstallOperation_Type_ZSTD;
  static inline bool Type_IsValid(int value) {
    return InstallOperation_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = InstallOperation_Type_Type_MIN;
  static constexpr Type Type_MAX = InstallOperation_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = InstallOperation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return InstallOperation_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return InstallOperation_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return InstallOperation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kSrcExtentsFieldNumber = 4,
    kDstExtentsFieldNumber = 6,
    kDataSha256HashFieldNumber = 8,
    kSrcSha256HashFieldNumber = 9,
    kDataOffsetFieldNumber = 2,
    kDataLengthFieldNumber = 3,
    kSrcLengthFieldNumber = 5,
    kDstLengthFieldNumber = 7,
    kTypeFieldNumber = 1,
  };
  // repeated .chromeos_update_engine.Extent src_extents = 4;
  int src_extents_size() const;
  private:
  int _internal_src_extents_size() const;

  public:
  void clear_src_extents() ;
  ::chromeos_update_engine::Extent* mutable_src_extents(int index);
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>* mutable_src_extents();

  private:
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>& _internal_src_extents() const;
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>* _internal_mutable_src_extents();
  public:
  const ::chromeos_update_engine::Extent& src_extents(int index) const;
  ::chromeos_update_engine::Extent* add_src_extents();
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>& src_extents() const;
  // repeated .chromeos_update_engine.Extent dst_extents = 6;
  int dst_extents_size() const;
  private:
  int _internal_dst_extents_size() const;

  public:
  void clear_dst_extents() ;
  ::chromeos_update_engine::Extent* mutable_dst_extents(int index);
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>* mutable_dst_extents();

  private:
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>& _internal_dst_extents() const;
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>* _internal_mutable_dst_extents();
  public:
  const ::chromeos_update_engine::Extent& dst_extents(int index) const;
  ::chromeos_update_engine::Extent* add_dst_extents();
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>& dst_extents() const;
  // optional bytes data_sha256_hash = 8;
  bool has_data_sha256_hash() const;
  void clear_data_sha256_hash() ;
  const std::string& data_sha256_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_sha256_hash(Arg_&& arg, Args_... args);
  std::string* mutable_data_sha256_hash();
  PROTOBUF_NODISCARD std::string* release_data_sha256_hash();
  void set_allocated_data_sha256_hash(std::string* value);

  private:
  const std::string& _internal_data_sha256_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_sha256_hash(
      const std::string& value);
  std::string* _internal_mutable_data_sha256_hash();

  public:
  // optional bytes src_sha256_hash = 9;
  bool has_src_sha256_hash() const;
  void clear_src_sha256_hash() ;
  const std::string& src_sha256_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_src_sha256_hash(Arg_&& arg, Args_... args);
  std::string* mutable_src_sha256_hash();
  PROTOBUF_NODISCARD std::string* release_src_sha256_hash();
  void set_allocated_src_sha256_hash(std::string* value);

  private:
  const std::string& _internal_src_sha256_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_sha256_hash(
      const std::string& value);
  std::string* _internal_mutable_src_sha256_hash();

  public:
  // optional uint64 data_offset = 2;
  bool has_data_offset() const;
  void clear_data_offset() ;
  ::uint64_t data_offset() const;
  void set_data_offset(::uint64_t value);

  private:
  ::uint64_t _internal_data_offset() const;
  void _internal_set_data_offset(::uint64_t value);

  public:
  // optional uint64 data_length = 3;
  bool has_data_length() const;
  void clear_data_length() ;
  ::uint64_t data_length() const;
  void set_data_length(::uint64_t value);

  private:
  ::uint64_t _internal_data_length() const;
  void _internal_set_data_length(::uint64_t value);

  public:
  // optional uint64 src_length = 5;
  bool has_src_length() const;
  void clear_src_length() ;
  ::uint64_t src_length() const;
  void set_src_length(::uint64_t value);

  private:
  ::uint64_t _internal_src_length() const;
  void _internal_set_src_length(::uint64_t value);

  public:
  // optional uint64 dst_length = 7;
  bool has_dst_length() const;
  void clear_dst_length() ;
  ::uint64_t dst_length() const;
  void set_dst_length(::uint64_t value);

  private:
  ::uint64_t _internal_dst_length() const;
  void _internal_set_dst_length(::uint64_t value);

  public:
  // required .chromeos_update_engine.InstallOperation.Type type = 1;
  bool has_type() const;
  void clear_type() ;
  ::chromeos_update_engine::InstallOperation_Type type() const;
  void set_type(::chromeos_update_engine::InstallOperation_Type value);

  private:
  ::chromeos_update_engine::InstallOperation_Type _internal_type() const;
  void _internal_set_type(::chromeos_update_engine::InstallOperation_Type value);

  public:
  // @@protoc_insertion_point(class_scope:chromeos_update_engine.InstallOperation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InstallOperation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent > src_extents_;
    ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent > dst_extents_;
    ::google::protobuf::internal::ArenaStringPtr data_sha256_hash_;
    ::google::protobuf::internal::ArenaStringPtr src_sha256_hash_;
    ::uint64_t data_offset_;
    ::uint64_t data_length_;
    ::uint64_t src_length_;
    ::uint64_t dst_length_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class DynamicPartitionMetadata final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:chromeos_update_engine.DynamicPartitionMetadata) */ {
 public:
  inline DynamicPartitionMetadata() : DynamicPartitionMetadata(nullptr) {}
  ~DynamicPartitionMetadata() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DynamicPartitionMetadata* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DynamicPartitionMetadata));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DynamicPartitionMetadata(
      ::google::protobuf::internal::ConstantInitialized);

  inline DynamicPartitionMetadata(const DynamicPartitionMetadata& from) : DynamicPartitionMetadata(nullptr, from) {}
  inline DynamicPartitionMetadata(DynamicPartitionMetadata&& from) noexcept
      : DynamicPartitionMetadata(nullptr, std::move(from)) {}
  inline DynamicPartitionMetadata& operator=(const DynamicPartitionMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline DynamicPartitionMetadata& operator=(DynamicPartitionMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DynamicPartitionMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const DynamicPartitionMetadata* internal_default_instance() {
    return reinterpret_cast<const DynamicPartitionMetadata*>(
        &_DynamicPartitionMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(DynamicPartitionMetadata& a, DynamicPartitionMetadata& b) { a.Swap(&b); }
  inline void Swap(DynamicPartitionMetadata* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DynamicPartitionMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DynamicPartitionMetadata* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DynamicPartitionMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DynamicPartitionMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DynamicPartitionMetadata& from) { DynamicPartitionMetadata::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DynamicPartitionMetadata* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "chromeos_update_engine.DynamicPartitionMetadata"; }

 protected:
  explicit DynamicPartitionMetadata(::google::protobuf::Arena* arena);
  DynamicPartitionMetadata(::google::protobuf::Arena* arena, const DynamicPartitionMetadata& from);
  DynamicPartitionMetadata(::google::protobuf::Arena* arena, DynamicPartitionMetadata&& from) noexcept
      : DynamicPartitionMetadata(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGroupsFieldNumber = 1,
    kVabcCompressionParamFieldNumber = 4,
    kVabcFeatureSetFieldNumber = 6,
    kSnapshotEnabledFieldNumber = 2,
    kVabcEnabledFieldNumber = 3,
    kCowVersionFieldNumber = 5,
    kCompressionFactorFieldNumber = 7,
  };
  // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
  int groups_size() const;
  private:
  int _internal_groups_size() const;

  public:
  void clear_groups() ;
  ::chromeos_update_engine::DynamicPartitionGroup* mutable_groups(int index);
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::DynamicPartitionGroup>* mutable_groups();

  private:
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::DynamicPartitionGroup>& _internal_groups() const;
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::DynamicPartitionGroup>* _internal_mutable_groups();
  public:
  const ::chromeos_update_engine::DynamicPartitionGroup& groups(int index) const;
  ::chromeos_update_engine::DynamicPartitionGroup* add_groups();
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::DynamicPartitionGroup>& groups() const;
  // optional string vabc_compression_param = 4;
  bool has_vabc_compression_param() const;
  void clear_vabc_compression_param() ;
  const std::string& vabc_compression_param() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vabc_compression_param(Arg_&& arg, Args_... args);
  std::string* mutable_vabc_compression_param();
  PROTOBUF_NODISCARD std::string* release_vabc_compression_param();
  void set_allocated_vabc_compression_param(std::string* value);

  private:
  const std::string& _internal_vabc_compression_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vabc_compression_param(
      const std::string& value);
  std::string* _internal_mutable_vabc_compression_param();

  public:
  // optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
  bool has_vabc_feature_set() const;
  void clear_vabc_feature_set() ;
  const ::chromeos_update_engine::VABCFeatureSet& vabc_feature_set() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::VABCFeatureSet* release_vabc_feature_set();
  ::chromeos_update_engine::VABCFeatureSet* mutable_vabc_feature_set();
  void set_allocated_vabc_feature_set(::chromeos_update_engine::VABCFeatureSet* value);
  void unsafe_arena_set_allocated_vabc_feature_set(::chromeos_update_engine::VABCFeatureSet* value);
  ::chromeos_update_engine::VABCFeatureSet* unsafe_arena_release_vabc_feature_set();

  private:
  const ::chromeos_update_engine::VABCFeatureSet& _internal_vabc_feature_set() const;
  ::chromeos_update_engine::VABCFeatureSet* _internal_mutable_vabc_feature_set();

  public:
  // optional bool snapshot_enabled = 2;
  bool has_snapshot_enabled() const;
  void clear_snapshot_enabled() ;
  bool snapshot_enabled() const;
  void set_snapshot_enabled(bool value);

  private:
  bool _internal_snapshot_enabled() const;
  void _internal_set_snapshot_enabled(bool value);

  public:
  // optional bool vabc_enabled = 3;
  bool has_vabc_enabled() const;
  void clear_vabc_enabled() ;
  bool vabc_enabled() const;
  void set_vabc_enabled(bool value);

  private:
  bool _internal_vabc_enabled() const;
  void _internal_set_vabc_enabled(bool value);

  public:
  // optional uint32 cow_version = 5;
  bool has_cow_version() const;
  void clear_cow_version() ;
  ::uint32_t cow_version() const;
  void set_cow_version(::uint32_t value);

  private:
  ::uint32_t _internal_cow_version() const;
  void _internal_set_cow_version(::uint32_t value);

  public:
  // optional uint64 compression_factor = 7;
  bool has_compression_factor() const;
  void clear_compression_factor() ;
  ::uint64_t compression_factor() const;
  void set_compression_factor(::uint64_t value);

  private:
  ::uint64_t _internal_compression_factor() const;
  void _internal_set_compression_factor(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionMetadata)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      78, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DynamicPartitionMetadata& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup > groups_;
    ::google::protobuf::internal::ArenaStringPtr vabc_compression_param_;
    ::chromeos_update_engine::VABCFeatureSet* vabc_feature_set_;
    bool snapshot_enabled_;
    bool vabc_enabled_;
    ::uint32_t cow_version_;
    ::uint64_t compression_factor_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class CowMergeOperation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:chromeos_update_engine.CowMergeOperation) */ {
 public:
  inline CowMergeOperation() : CowMergeOperation(nullptr) {}
  ~CowMergeOperation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CowMergeOperation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CowMergeOperation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CowMergeOperation(
      ::google::protobuf::internal::ConstantInitialized);

  inline CowMergeOperation(const CowMergeOperation& from) : CowMergeOperation(nullptr, from) {}
  inline CowMergeOperation(CowMergeOperation&& from) noexcept
      : CowMergeOperation(nullptr, std::move(from)) {}
  inline CowMergeOperation& operator=(const CowMergeOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline CowMergeOperation& operator=(CowMergeOperation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CowMergeOperation& default_instance() {
    return *internal_default_instance();
  }
  static inline const CowMergeOperation* internal_default_instance() {
    return reinterpret_cast<const CowMergeOperation*>(
        &_CowMergeOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(CowMergeOperation& a, CowMergeOperation& b) { a.Swap(&b); }
  inline void Swap(CowMergeOperation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CowMergeOperation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CowMergeOperation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CowMergeOperation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CowMergeOperation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CowMergeOperation& from) { CowMergeOperation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CowMergeOperation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "chromeos_update_engine.CowMergeOperation"; }

 protected:
  explicit CowMergeOperation(::google::protobuf::Arena* arena);
  CowMergeOperation(::google::protobuf::Arena* arena, const CowMergeOperation& from);
  CowMergeOperation(::google::protobuf::Arena* arena, CowMergeOperation&& from) noexcept
      : CowMergeOperation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = CowMergeOperation_Type;
  static constexpr Type COW_COPY = CowMergeOperation_Type_COW_COPY;
  static constexpr Type COW_XOR = CowMergeOperation_Type_COW_XOR;
  static constexpr Type COW_REPLACE = CowMergeOperation_Type_COW_REPLACE;
  static inline bool Type_IsValid(int value) {
    return CowMergeOperation_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = CowMergeOperation_Type_Type_MIN;
  static constexpr Type Type_MAX = CowMergeOperation_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = CowMergeOperation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return CowMergeOperation_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return CowMergeOperation_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return CowMergeOperation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kSrcExtentFieldNumber = 2,
    kDstExtentFieldNumber = 3,
    kTypeFieldNumber = 1,
    kSrcOffsetFieldNumber = 4,
  };
  // optional .chromeos_update_engine.Extent src_extent = 2;
  bool has_src_extent() const;
  void clear_src_extent() ;
  const ::chromeos_update_engine::Extent& src_extent() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::Extent* release_src_extent();
  ::chromeos_update_engine::Extent* mutable_src_extent();
  void set_allocated_src_extent(::chromeos_update_engine::Extent* value);
  void unsafe_arena_set_allocated_src_extent(::chromeos_update_engine::Extent* value);
  ::chromeos_update_engine::Extent* unsafe_arena_release_src_extent();

  private:
  const ::chromeos_update_engine::Extent& _internal_src_extent() const;
  ::chromeos_update_engine::Extent* _internal_mutable_src_extent();

  public:
  // optional .chromeos_update_engine.Extent dst_extent = 3;
  bool has_dst_extent() const;
  void clear_dst_extent() ;
  const ::chromeos_update_engine::Extent& dst_extent() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::Extent* release_dst_extent();
  ::chromeos_update_engine::Extent* mutable_dst_extent();
  void set_allocated_dst_extent(::chromeos_update_engine::Extent* value);
  void unsafe_arena_set_allocated_dst_extent(::chromeos_update_engine::Extent* value);
  ::chromeos_update_engine::Extent* unsafe_arena_release_dst_extent();

  private:
  const ::chromeos_update_engine::Extent& _internal_dst_extent() const;
  ::chromeos_update_engine::Extent* _internal_mutable_dst_extent();

  public:
  // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
  bool has_type() const;
  void clear_type() ;
  ::chromeos_update_engine::CowMergeOperation_Type type() const;
  void set_type(::chromeos_update_engine::CowMergeOperation_Type value);

  private:
  ::chromeos_update_engine::CowMergeOperation_Type _internal_type() const;
  void _internal_set_type(::chromeos_update_engine::CowMergeOperation_Type value);

  public:
  // optional uint32 src_offset = 4;
  bool has_src_offset() const;
  void clear_src_offset() ;
  ::uint32_t src_offset() const;
  void set_src_offset(::uint32_t value);

  private:
  ::uint32_t _internal_src_offset() const;
  void _internal_set_src_offset(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:chromeos_update_engine.CowMergeOperation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CowMergeOperation& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::chromeos_update_engine::Extent* src_extent_;
    ::chromeos_update_engine::Extent* dst_extent_;
    int type_;
    ::uint32_t src_offset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ApexMetadata final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:chromeos_update_engine.ApexMetadata) */ {
 public:
  inline ApexMetadata() : ApexMetadata(nullptr) {}
  ~ApexMetadata() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ApexMetadata* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ApexMetadata));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ApexMetadata(
      ::google::protobuf::internal::ConstantInitialized);

  inline ApexMetadata(const ApexMetadata& from) : ApexMetadata(nullptr, from) {}
  inline ApexMetadata(ApexMetadata&& from) noexcept
      : ApexMetadata(nullptr, std::move(from)) {}
  inline ApexMetadata& operator=(const ApexMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApexMetadata& operator=(ApexMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApexMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApexMetadata* internal_default_instance() {
    return reinterpret_cast<const ApexMetadata*>(
        &_ApexMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ApexMetadata& a, ApexMetadata& b) { a.Swap(&b); }
  inline void Swap(ApexMetadata* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApexMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApexMetadata* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ApexMetadata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ApexMetadata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ApexMetadata& from) { ApexMetadata::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ApexMetadata* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "chromeos_update_engine.ApexMetadata"; }

 protected:
  explicit ApexMetadata(::google::protobuf::Arena* arena);
  ApexMetadata(::google::protobuf::Arena* arena, const ApexMetadata& from);
  ApexMetadata(::google::protobuf::Arena* arena, ApexMetadata&& from) noexcept
      : ApexMetadata(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kApexInfoFieldNumber = 1,
  };
  // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
  int apex_info_size() const;
  private:
  int _internal_apex_info_size() const;

  public:
  void clear_apex_info() ;
  ::chromeos_update_engine::ApexInfo* mutable_apex_info(int index);
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>* mutable_apex_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>& _internal_apex_info() const;
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>* _internal_mutable_apex_info();
  public:
  const ::chromeos_update_engine::ApexInfo& apex_info(int index) const;
  ::chromeos_update_engine::ApexInfo* add_apex_info();
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>& apex_info() const;
  // @@protoc_insertion_point(class_scope:chromeos_update_engine.ApexMetadata)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ApexMetadata& from_msg);
    ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::ApexInfo > apex_info_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class PartitionUpdate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:chromeos_update_engine.PartitionUpdate) */ {
 public:
  inline PartitionUpdate() : PartitionUpdate(nullptr) {}
  ~PartitionUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PartitionUpdate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PartitionUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PartitionUpdate(
      ::google::protobuf::internal::ConstantInitialized);

  inline PartitionUpdate(const PartitionUpdate& from) : PartitionUpdate(nullptr, from) {}
  inline PartitionUpdate(PartitionUpdate&& from) noexcept
      : PartitionUpdate(nullptr, std::move(from)) {}
  inline PartitionUpdate& operator=(const PartitionUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionUpdate& operator=(PartitionUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionUpdate* internal_default_instance() {
    return reinterpret_cast<const PartitionUpdate*>(
        &_PartitionUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(PartitionUpdate& a, PartitionUpdate& b) { a.Swap(&b); }
  inline void Swap(PartitionUpdate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitionUpdate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PartitionUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PartitionUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PartitionUpdate& from) { PartitionUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PartitionUpdate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "chromeos_update_engine.PartitionUpdate"; }

 protected:
  explicit PartitionUpdate(::google::protobuf::Arena* arena);
  PartitionUpdate(::google::protobuf::Arena* arena, const PartitionUpdate& from);
  PartitionUpdate(::google::protobuf::Arena* arena, PartitionUpdate&& from) noexcept
      : PartitionUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewPartitionSignatureFieldNumber = 5,
    kOperationsFieldNumber = 8,
    kMergeOperationsFieldNumber = 18,
    kPartitionNameFieldNumber = 1,
    kPostinstallPathFieldNumber = 3,
    kFilesystemTypeFieldNumber = 4,
    kHashTreeAlgorithmFieldNumber = 12,
    kHashTreeSaltFieldNumber = 13,
    kVersionFieldNumber = 17,
    kOldPartitionInfoFieldNumber = 6,
    kNewPartitionInfoFieldNumber = 7,
    kHashTreeDataExtentFieldNumber = 10,
    kHashTreeExtentFieldNumber = 11,
    kFecDataExtentFieldNumber = 14,
    kFecExtentFieldNumber = 15,
    kEstimateCowSizeFieldNumber = 19,
    kEstimateOpCountMaxFieldNumber = 20,
    kRunPostinstallFieldNumber = 2,
    kPostinstallOptionalFieldNumber = 9,
    kFecRootsFieldNumber = 16,
  };
  // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
  int new_partition_signature_size() const;
  private:
  int _internal_new_partition_signature_size() const;

  public:
  void clear_new_partition_signature() ;
  ::chromeos_update_engine::Signatures_Signature* mutable_new_partition_signature(int index);
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>* mutable_new_partition_signature();

  private:
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>& _internal_new_partition_signature() const;
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>* _internal_mutable_new_partition_signature();
  public:
  const ::chromeos_update_engine::Signatures_Signature& new_partition_signature(int index) const;
  ::chromeos_update_engine::Signatures_Signature* add_new_partition_signature();
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>& new_partition_signature() const;
  // repeated .chromeos_update_engine.InstallOperation operations = 8;
  int operations_size() const;
  private:
  int _internal_operations_size() const;

  public:
  void clear_operations() ;
  ::chromeos_update_engine::InstallOperation* mutable_operations(int index);
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::InstallOperation>* mutable_operations();

  private:
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::InstallOperation>& _internal_operations() const;
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::InstallOperation>* _internal_mutable_operations();
  public:
  const ::chromeos_update_engine::InstallOperation& operations(int index) const;
  ::chromeos_update_engine::InstallOperation* add_operations();
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::InstallOperation>& operations() const;
  // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
  int merge_operations_size() const;
  private:
  int _internal_merge_operations_size() const;

  public:
  void clear_merge_operations() ;
  ::chromeos_update_engine::CowMergeOperation* mutable_merge_operations(int index);
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::CowMergeOperation>* mutable_merge_operations();

  private:
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::CowMergeOperation>& _internal_merge_operations() const;
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::CowMergeOperation>* _internal_mutable_merge_operations();
  public:
  const ::chromeos_update_engine::CowMergeOperation& merge_operations(int index) const;
  ::chromeos_update_engine::CowMergeOperation* add_merge_operations();
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::CowMergeOperation>& merge_operations() const;
  // required string partition_name = 1;
  bool has_partition_name() const;
  void clear_partition_name() ;
  const std::string& partition_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_partition_name(Arg_&& arg, Args_... args);
  std::string* mutable_partition_name();
  PROTOBUF_NODISCARD std::string* release_partition_name();
  void set_allocated_partition_name(std::string* value);

  private:
  const std::string& _internal_partition_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_name(
      const std::string& value);
  std::string* _internal_mutable_partition_name();

  public:
  // optional string postinstall_path = 3;
  bool has_postinstall_path() const;
  void clear_postinstall_path() ;
  const std::string& postinstall_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_postinstall_path(Arg_&& arg, Args_... args);
  std::string* mutable_postinstall_path();
  PROTOBUF_NODISCARD std::string* release_postinstall_path();
  void set_allocated_postinstall_path(std::string* value);

  private:
  const std::string& _internal_postinstall_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_postinstall_path(
      const std::string& value);
  std::string* _internal_mutable_postinstall_path();

  public:
  // optional string filesystem_type = 4;
  bool has_filesystem_type() const;
  void clear_filesystem_type() ;
  const std::string& filesystem_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filesystem_type(Arg_&& arg, Args_... args);
  std::string* mutable_filesystem_type();
  PROTOBUF_NODISCARD std::string* release_filesystem_type();
  void set_allocated_filesystem_type(std::string* value);

  private:
  const std::string& _internal_filesystem_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filesystem_type(
      const std::string& value);
  std::string* _internal_mutable_filesystem_type();

  public:
  // optional string hash_tree_algorithm = 12;
  bool has_hash_tree_algorithm() const;
  void clear_hash_tree_algorithm() ;
  const std::string& hash_tree_algorithm() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash_tree_algorithm(Arg_&& arg, Args_... args);
  std::string* mutable_hash_tree_algorithm();
  PROTOBUF_NODISCARD std::string* release_hash_tree_algorithm();
  void set_allocated_hash_tree_algorithm(std::string* value);

  private:
  const std::string& _internal_hash_tree_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash_tree_algorithm(
      const std::string& value);
  std::string* _internal_mutable_hash_tree_algorithm();

  public:
  // optional bytes hash_tree_salt = 13;
  bool has_hash_tree_salt() const;
  void clear_hash_tree_salt() ;
  const std::string& hash_tree_salt() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash_tree_salt(Arg_&& arg, Args_... args);
  std::string* mutable_hash_tree_salt();
  PROTOBUF_NODISCARD std::string* release_hash_tree_salt();
  void set_allocated_hash_tree_salt(std::string* value);

  private:
  const std::string& _internal_hash_tree_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash_tree_salt(
      const std::string& value);
  std::string* _internal_mutable_hash_tree_salt();

  public:
  // optional string version = 17;
  bool has_version() const;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
  bool has_old_partition_info() const;
  void clear_old_partition_info() ;
  const ::chromeos_update_engine::PartitionInfo& old_partition_info() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::PartitionInfo* release_old_partition_info();
  ::chromeos_update_engine::PartitionInfo* mutable_old_partition_info();
  void set_allocated_old_partition_info(::chromeos_update_engine::PartitionInfo* value);
  void unsafe_arena_set_allocated_old_partition_info(::chromeos_update_engine::PartitionInfo* value);
  ::chromeos_update_engine::PartitionInfo* unsafe_arena_release_old_partition_info();

  private:
  const ::chromeos_update_engine::PartitionInfo& _internal_old_partition_info() const;
  ::chromeos_update_engine::PartitionInfo* _internal_mutable_old_partition_info();

  public:
  // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
  bool has_new_partition_info() const;
  void clear_new_partition_info() ;
  const ::chromeos_update_engine::PartitionInfo& new_partition_info() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::PartitionInfo* release_new_partition_info();
  ::chromeos_update_engine::PartitionInfo* mutable_new_partition_info();
  void set_allocated_new_partition_info(::chromeos_update_engine::PartitionInfo* value);
  void unsafe_arena_set_allocated_new_partition_info(::chromeos_update_engine::PartitionInfo* value);
  ::chromeos_update_engine::PartitionInfo* unsafe_arena_release_new_partition_info();

  private:
  const ::chromeos_update_engine::PartitionInfo& _internal_new_partition_info() const;
  ::chromeos_update_engine::PartitionInfo* _internal_mutable_new_partition_info();

  public:
  // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
  bool has_hash_tree_data_extent() const;
  void clear_hash_tree_data_extent() ;
  const ::chromeos_update_engine::Extent& hash_tree_data_extent() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::Extent* release_hash_tree_data_extent();
  ::chromeos_update_engine::Extent* mutable_hash_tree_data_extent();
  void set_allocated_hash_tree_data_extent(::chromeos_update_engine::Extent* value);
  void unsafe_arena_set_allocated_hash_tree_data_extent(::chromeos_update_engine::Extent* value);
  ::chromeos_update_engine::Extent* unsafe_arena_release_hash_tree_data_extent();

  private:
  const ::chromeos_update_engine::Extent& _internal_hash_tree_data_extent() const;
  ::chromeos_update_engine::Extent* _internal_mutable_hash_tree_data_extent();

  public:
  // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
  bool has_hash_tree_extent() const;
  void clear_hash_tree_extent() ;
  const ::chromeos_update_engine::Extent& hash_tree_extent() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::Extent* release_hash_tree_extent();
  ::chromeos_update_engine::Extent* mutable_hash_tree_extent();
  void set_allocated_hash_tree_extent(::chromeos_update_engine::Extent* value);
  void unsafe_arena_set_allocated_hash_tree_extent(::chromeos_update_engine::Extent* value);
  ::chromeos_update_engine::Extent* unsafe_arena_release_hash_tree_extent();

  private:
  const ::chromeos_update_engine::Extent& _internal_hash_tree_extent() const;
  ::chromeos_update_engine::Extent* _internal_mutable_hash_tree_extent();

  public:
  // optional .chromeos_update_engine.Extent fec_data_extent = 14;
  bool has_fec_data_extent() const;
  void clear_fec_data_extent() ;
  const ::chromeos_update_engine::Extent& fec_data_extent() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::Extent* release_fec_data_extent();
  ::chromeos_update_engine::Extent* mutable_fec_data_extent();
  void set_allocated_fec_data_extent(::chromeos_update_engine::Extent* value);
  void unsafe_arena_set_allocated_fec_data_extent(::chromeos_update_engine::Extent* value);
  ::chromeos_update_engine::Extent* unsafe_arena_release_fec_data_extent();

  private:
  const ::chromeos_update_engine::Extent& _internal_fec_data_extent() const;
  ::chromeos_update_engine::Extent* _internal_mutable_fec_data_extent();

  public:
  // optional .chromeos_update_engine.Extent fec_extent = 15;
  bool has_fec_extent() const;
  void clear_fec_extent() ;
  const ::chromeos_update_engine::Extent& fec_extent() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::Extent* release_fec_extent();
  ::chromeos_update_engine::Extent* mutable_fec_extent();
  void set_allocated_fec_extent(::chromeos_update_engine::Extent* value);
  void unsafe_arena_set_allocated_fec_extent(::chromeos_update_engine::Extent* value);
  ::chromeos_update_engine::Extent* unsafe_arena_release_fec_extent();

  private:
  const ::chromeos_update_engine::Extent& _internal_fec_extent() const;
  ::chromeos_update_engine::Extent* _internal_mutable_fec_extent();

  public:
  // optional uint64 estimate_cow_size = 19;
  bool has_estimate_cow_size() const;
  void clear_estimate_cow_size() ;
  ::uint64_t estimate_cow_size() const;
  void set_estimate_cow_size(::uint64_t value);

  private:
  ::uint64_t _internal_estimate_cow_size() const;
  void _internal_set_estimate_cow_size(::uint64_t value);

  public:
  // optional uint64 estimate_op_count_max = 20;
  bool has_estimate_op_count_max() const;
  void clear_estimate_op_count_max() ;
  ::uint64_t estimate_op_count_max() const;
  void set_estimate_op_count_max(::uint64_t value);

  private:
  ::uint64_t _internal_estimate_op_count_max() const;
  void _internal_set_estimate_op_count_max(::uint64_t value);

  public:
  // optional bool run_postinstall = 2;
  bool has_run_postinstall() const;
  void clear_run_postinstall() ;
  bool run_postinstall() const;
  void set_run_postinstall(bool value);

  private:
  bool _internal_run_postinstall() const;
  void _internal_set_run_postinstall(bool value);

  public:
  // optional bool postinstall_optional = 9;
  bool has_postinstall_optional() const;
  void clear_postinstall_optional() ;
  bool postinstall_optional() const;
  void set_postinstall_optional(bool value);

  private:
  bool _internal_postinstall_optional() const;
  void _internal_set_postinstall_optional(bool value);

  public:
  // optional uint32 fec_roots = 16 [default = 2];
  bool has_fec_roots() const;
  void clear_fec_roots() ;
  ::uint32_t fec_roots() const;
  void set_fec_roots(::uint32_t value);

  private:
  ::uint32_t _internal_fec_roots() const;
  void _internal_set_fec_roots(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionUpdate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 20, 9,
      134, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PartitionUpdate& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature > new_partition_signature_;
    ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation > operations_;
    ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation > merge_operations_;
    ::google::protobuf::internal::ArenaStringPtr partition_name_;
    ::google::protobuf::internal::ArenaStringPtr postinstall_path_;
    ::google::protobuf::internal::ArenaStringPtr filesystem_type_;
    ::google::protobuf::internal::ArenaStringPtr hash_tree_algorithm_;
    ::google::protobuf::internal::ArenaStringPtr hash_tree_salt_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::chromeos_update_engine::PartitionInfo* old_partition_info_;
    ::chromeos_update_engine::PartitionInfo* new_partition_info_;
    ::chromeos_update_engine::Extent* hash_tree_data_extent_;
    ::chromeos_update_engine::Extent* hash_tree_extent_;
    ::chromeos_update_engine::Extent* fec_data_extent_;
    ::chromeos_update_engine::Extent* fec_extent_;
    ::uint64_t estimate_cow_size_;
    ::uint64_t estimate_op_count_max_;
    bool run_postinstall_;
    bool postinstall_optional_;
    ::uint32_t fec_roots_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class DeltaArchiveManifest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:chromeos_update_engine.DeltaArchiveManifest) */ {
 public:
  inline DeltaArchiveManifest() : DeltaArchiveManifest(nullptr) {}
  ~DeltaArchiveManifest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeltaArchiveManifest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeltaArchiveManifest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeltaArchiveManifest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeltaArchiveManifest(const DeltaArchiveManifest& from) : DeltaArchiveManifest(nullptr, from) {}
  inline DeltaArchiveManifest(DeltaArchiveManifest&& from) noexcept
      : DeltaArchiveManifest(nullptr, std::move(from)) {}
  inline DeltaArchiveManifest& operator=(const DeltaArchiveManifest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeltaArchiveManifest& operator=(DeltaArchiveManifest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeltaArchiveManifest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeltaArchiveManifest* internal_default_instance() {
    return reinterpret_cast<const DeltaArchiveManifest*>(
        &_DeltaArchiveManifest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(DeltaArchiveManifest& a, DeltaArchiveManifest& b) { a.Swap(&b); }
  inline void Swap(DeltaArchiveManifest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeltaArchiveManifest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeltaArchiveManifest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeltaArchiveManifest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeltaArchiveManifest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeltaArchiveManifest& from) { DeltaArchiveManifest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeltaArchiveManifest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "chromeos_update_engine.DeltaArchiveManifest"; }

 protected:
  explicit DeltaArchiveManifest(::google::protobuf::Arena* arena);
  DeltaArchiveManifest(::google::protobuf::Arena* arena, const DeltaArchiveManifest& from);
  DeltaArchiveManifest(::google::protobuf::Arena* arena, DeltaArchiveManifest&& from) noexcept
      : DeltaArchiveManifest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPartitionsFieldNumber = 13,
    kApexInfoFieldNumber = 17,
    kSecurityPatchLevelFieldNumber = 18,
    kDynamicPartitionMetadataFieldNumber = 15,
    kSignaturesOffsetFieldNumber = 4,
    kSignaturesSizeFieldNumber = 5,
    kMaxTimestampFieldNumber = 14,
    kMinorVersionFieldNumber = 12,
    kPartialUpdateFieldNumber = 16,
    kBlockSizeFieldNumber = 3,
  };
  // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
  int partitions_size() const;
  private:
  int _internal_partitions_size() const;

  public:
  void clear_partitions() ;
  ::chromeos_update_engine::PartitionUpdate* mutable_partitions(int index);
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::PartitionUpdate>* mutable_partitions();

  private:
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::PartitionUpdate>& _internal_partitions() const;
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::PartitionUpdate>* _internal_mutable_partitions();
  public:
  const ::chromeos_update_engine::PartitionUpdate& partitions(int index) const;
  ::chromeos_update_engine::PartitionUpdate* add_partitions();
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::PartitionUpdate>& partitions() const;
  // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
  int apex_info_size() const;
  private:
  int _internal_apex_info_size() const;

  public:
  void clear_apex_info() ;
  ::chromeos_update_engine::ApexInfo* mutable_apex_info(int index);
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>* mutable_apex_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>& _internal_apex_info() const;
  ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>* _internal_mutable_apex_info();
  public:
  const ::chromeos_update_engine::ApexInfo& apex_info(int index) const;
  ::chromeos_update_engine::ApexInfo* add_apex_info();
  const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>& apex_info() const;
  // optional string security_patch_level = 18;
  bool has_security_patch_level() const;
  void clear_security_patch_level() ;
  const std::string& security_patch_level() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_security_patch_level(Arg_&& arg, Args_... args);
  std::string* mutable_security_patch_level();
  PROTOBUF_NODISCARD std::string* release_security_patch_level();
  void set_allocated_security_patch_level(std::string* value);

  private:
  const std::string& _internal_security_patch_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_security_patch_level(
      const std::string& value);
  std::string* _internal_mutable_security_patch_level();

  public:
  // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
  bool has_dynamic_partition_metadata() const;
  void clear_dynamic_partition_metadata() ;
  const ::chromeos_update_engine::DynamicPartitionMetadata& dynamic_partition_metadata() const;
  PROTOBUF_NODISCARD ::chromeos_update_engine::DynamicPartitionMetadata* release_dynamic_partition_metadata();
  ::chromeos_update_engine::DynamicPartitionMetadata* mutable_dynamic_partition_metadata();
  void set_allocated_dynamic_partition_metadata(::chromeos_update_engine::DynamicPartitionMetadata* value);
  void unsafe_arena_set_allocated_dynamic_partition_metadata(::chromeos_update_engine::DynamicPartitionMetadata* value);
  ::chromeos_update_engine::DynamicPartitionMetadata* unsafe_arena_release_dynamic_partition_metadata();

  private:
  const ::chromeos_update_engine::DynamicPartitionMetadata& _internal_dynamic_partition_metadata() const;
  ::chromeos_update_engine::DynamicPartitionMetadata* _internal_mutable_dynamic_partition_metadata();

  public:
  // optional uint64 signatures_offset = 4;
  bool has_signatures_offset() const;
  void clear_signatures_offset() ;
  ::uint64_t signatures_offset() const;
  void set_signatures_offset(::uint64_t value);

  private:
  ::uint64_t _internal_signatures_offset() const;
  void _internal_set_signatures_offset(::uint64_t value);

  public:
  // optional uint64 signatures_size = 5;
  bool has_signatures_size() const;
  void clear_signatures_size() ;
  ::uint64_t signatures_size() const;
  void set_signatures_size(::uint64_t value);

  private:
  ::uint64_t _internal_signatures_size() const;
  void _internal_set_signatures_size(::uint64_t value);

  public:
  // optional int64 max_timestamp = 14;
  bool has_max_timestamp() const;
  void clear_max_timestamp() ;
  ::int64_t max_timestamp() const;
  void set_max_timestamp(::int64_t value);

  private:
  ::int64_t _internal_max_timestamp() const;
  void _internal_set_max_timestamp(::int64_t value);

  public:
  // optional uint32 minor_version = 12 [default = 0];
  bool has_minor_version() const;
  void clear_minor_version() ;
  ::uint32_t minor_version() const;
  void set_minor_version(::uint32_t value);

  private:
  ::uint32_t _internal_minor_version() const;
  void _internal_set_minor_version(::uint32_t value);

  public:
  // optional bool partial_update = 16;
  bool has_partial_update() const;
  void clear_partial_update() ;
  bool partial_update() const;
  void set_partial_update(bool value);

  private:
  bool _internal_partial_update() const;
  void _internal_set_partial_update(bool value);

  public:
  // optional uint32 block_size = 3 [default = 4096];
  bool has_block_size() const;
  void clear_block_size() ;
  ::uint32_t block_size() const;
  void set_block_size(::uint32_t value);

  private:
  ::uint32_t _internal_block_size() const;
  void _internal_set_block_size(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:chromeos_update_engine.DeltaArchiveManifest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 3,
      80, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeltaArchiveManifest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate > partitions_;
    ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::ApexInfo > apex_info_;
    ::google::protobuf::internal::ArenaStringPtr security_patch_level_;
    ::chromeos_update_engine::DynamicPartitionMetadata* dynamic_partition_metadata_;
    ::uint64_t signatures_offset_;
    ::uint64_t signatures_size_;
    ::int64_t max_timestamp_;
    ::uint32_t minor_version_;
    bool partial_update_;
    ::uint32_t block_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Extent

// optional uint64 start_block = 1;
inline bool Extent::has_start_block() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Extent::clear_start_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_block_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t Extent::start_block() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Extent.start_block)
  return _internal_start_block();
}
inline void Extent::set_start_block(::uint64_t value) {
  _internal_set_start_block(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Extent.start_block)
}
inline ::uint64_t Extent::_internal_start_block() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_block_;
}
inline void Extent::_internal_set_start_block(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_block_ = value;
}

// optional uint64 num_blocks = 2;
inline bool Extent::has_num_blocks() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Extent::clear_num_blocks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_blocks_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t Extent::num_blocks() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Extent.num_blocks)
  return _internal_num_blocks();
}
inline void Extent::set_num_blocks(::uint64_t value) {
  _internal_set_num_blocks(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Extent.num_blocks)
}
inline ::uint64_t Extent::_internal_num_blocks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.num_blocks_;
}
inline void Extent::_internal_set_num_blocks(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.num_blocks_ = value;
}

// -------------------------------------------------------------------

// Signatures_Signature

// optional uint32 version = 1 [deprecated = true];
inline bool Signatures_Signature::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Signatures_Signature::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t Signatures_Signature::version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.Signature.version)
  return _internal_version();
}
inline void Signatures_Signature::set_version(::uint32_t value) {
  _internal_set_version(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Signatures.Signature.version)
}
inline ::uint32_t Signatures_Signature::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_;
}
inline void Signatures_Signature::_internal_set_version(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// optional bytes data = 2;
inline bool Signatures_Signature::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Signatures_Signature::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Signatures_Signature::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.Signature.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Signatures_Signature::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Signatures.Signature.data)
}
inline std::string* Signatures_Signature::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.Signatures.Signature.data)
  return _s;
}
inline const std::string& Signatures_Signature::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void Signatures_Signature::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_.Set(value, GetArena());
}
inline std::string* Signatures_Signature::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* Signatures_Signature::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.Signatures.Signature.data)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.data_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.data_.Set("", GetArena());
  }
  return released;
}
inline void Signatures_Signature::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.Signatures.Signature.data)
}

// optional fixed32 unpadded_signature_size = 3;
inline bool Signatures_Signature::has_unpadded_signature_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Signatures_Signature::clear_unpadded_signature_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unpadded_signature_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t Signatures_Signature::unpadded_signature_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.Signature.unpadded_signature_size)
  return _internal_unpadded_signature_size();
}
inline void Signatures_Signature::set_unpadded_signature_size(::uint32_t value) {
  _internal_set_unpadded_signature_size(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Signatures.Signature.unpadded_signature_size)
}
inline ::uint32_t Signatures_Signature::_internal_unpadded_signature_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.unpadded_signature_size_;
}
inline void Signatures_Signature::_internal_set_unpadded_signature_size(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.unpadded_signature_size_ = value;
}

// -------------------------------------------------------------------

// Signatures

// repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
inline int Signatures::_internal_signatures_size() const {
  return _internal_signatures().size();
}
inline int Signatures::signatures_size() const {
  return _internal_signatures_size();
}
inline void Signatures::clear_signatures() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signatures_.Clear();
}
inline ::chromeos_update_engine::Signatures_Signature* Signatures::mutable_signatures(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.Signatures.signatures)
  return _internal_mutable_signatures()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>* Signatures::mutable_signatures()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.Signatures.signatures)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_signatures();
}
inline const ::chromeos_update_engine::Signatures_Signature& Signatures::signatures(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.signatures)
  return _internal_signatures().Get(index);
}
inline ::chromeos_update_engine::Signatures_Signature* Signatures::add_signatures() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::chromeos_update_engine::Signatures_Signature* _add = _internal_mutable_signatures()->Add();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.Signatures.signatures)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>& Signatures::signatures() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.Signatures.signatures)
  return _internal_signatures();
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>&
Signatures::_internal_signatures() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signatures_;
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>*
Signatures::_internal_mutable_signatures() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.signatures_;
}

// -------------------------------------------------------------------

// PartitionInfo

// optional uint64 size = 1;
inline bool PartitionInfo::has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PartitionInfo::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t PartitionInfo::size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionInfo.size)
  return _internal_size();
}
inline void PartitionInfo::set_size(::uint64_t value) {
  _internal_set_size(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionInfo.size)
}
inline ::uint64_t PartitionInfo::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void PartitionInfo::_internal_set_size(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// optional bytes hash = 2;
inline bool PartitionInfo::has_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PartitionInfo::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PartitionInfo::hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionInfo.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PartitionInfo::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionInfo.hash)
}
inline std::string* PartitionInfo::mutable_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionInfo.hash)
  return _s;
}
inline const std::string& PartitionInfo::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash_.Get();
}
inline void PartitionInfo::_internal_set_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hash_.Set(value, GetArena());
}
inline std::string* PartitionInfo::_internal_mutable_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.hash_.Mutable( GetArena());
}
inline std::string* PartitionInfo::release_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionInfo.hash)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.hash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.hash_.Set("", GetArena());
  }
  return released;
}
inline void PartitionInfo::set_allocated_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionInfo.hash)
}

// -------------------------------------------------------------------

// InstallOperation

// required .chromeos_update_engine.InstallOperation.Type type = 1;
inline bool InstallOperation::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void InstallOperation::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::chromeos_update_engine::InstallOperation_Type InstallOperation::type() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.type)
  return _internal_type();
}
inline void InstallOperation::set_type(::chromeos_update_engine::InstallOperation_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.type)
}
inline ::chromeos_update_engine::InstallOperation_Type InstallOperation::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::chromeos_update_engine::InstallOperation_Type>(_impl_.type_);
}
inline void InstallOperation::_internal_set_type(::chromeos_update_engine::InstallOperation_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::chromeos_update_engine::InstallOperation_Type_IsValid(value));
  _impl_.type_ = value;
}

// optional uint64 data_offset = 2;
inline bool InstallOperation::has_data_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void InstallOperation::clear_data_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_offset_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t InstallOperation::data_offset() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.data_offset)
  return _internal_data_offset();
}
inline void InstallOperation::set_data_offset(::uint64_t value) {
  _internal_set_data_offset(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.data_offset)
}
inline ::uint64_t InstallOperation::_internal_data_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_offset_;
}
inline void InstallOperation::_internal_set_data_offset(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_offset_ = value;
}

// optional uint64 data_length = 3;
inline bool InstallOperation::has_data_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void InstallOperation::clear_data_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_length_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t InstallOperation::data_length() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.data_length)
  return _internal_data_length();
}
inline void InstallOperation::set_data_length(::uint64_t value) {
  _internal_set_data_length(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.data_length)
}
inline ::uint64_t InstallOperation::_internal_data_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_length_;
}
inline void InstallOperation::_internal_set_data_length(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_length_ = value;
}

// repeated .chromeos_update_engine.Extent src_extents = 4;
inline int InstallOperation::_internal_src_extents_size() const {
  return _internal_src_extents().size();
}
inline int InstallOperation::src_extents_size() const {
  return _internal_src_extents_size();
}
inline void InstallOperation::clear_src_extents() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_extents_.Clear();
}
inline ::chromeos_update_engine::Extent* InstallOperation::mutable_src_extents(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.src_extents)
  return _internal_mutable_src_extents()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>* InstallOperation::mutable_src_extents()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.InstallOperation.src_extents)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_src_extents();
}
inline const ::chromeos_update_engine::Extent& InstallOperation::src_extents(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.src_extents)
  return _internal_src_extents().Get(index);
}
inline ::chromeos_update_engine::Extent* InstallOperation::add_src_extents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::chromeos_update_engine::Extent* _add = _internal_mutable_src_extents()->Add();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.InstallOperation.src_extents)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>& InstallOperation::src_extents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.InstallOperation.src_extents)
  return _internal_src_extents();
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>&
InstallOperation::_internal_src_extents() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.src_extents_;
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>*
InstallOperation::_internal_mutable_src_extents() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.src_extents_;
}

// optional uint64 src_length = 5;
inline bool InstallOperation::has_src_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void InstallOperation::clear_src_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_length_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint64_t InstallOperation::src_length() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.src_length)
  return _internal_src_length();
}
inline void InstallOperation::set_src_length(::uint64_t value) {
  _internal_set_src_length(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.src_length)
}
inline ::uint64_t InstallOperation::_internal_src_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.src_length_;
}
inline void InstallOperation::_internal_set_src_length(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_length_ = value;
}

// repeated .chromeos_update_engine.Extent dst_extents = 6;
inline int InstallOperation::_internal_dst_extents_size() const {
  return _internal_dst_extents().size();
}
inline int InstallOperation::dst_extents_size() const {
  return _internal_dst_extents_size();
}
inline void InstallOperation::clear_dst_extents() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dst_extents_.Clear();
}
inline ::chromeos_update_engine::Extent* InstallOperation::mutable_dst_extents(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.dst_extents)
  return _internal_mutable_dst_extents()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>* InstallOperation::mutable_dst_extents()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.InstallOperation.dst_extents)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dst_extents();
}
inline const ::chromeos_update_engine::Extent& InstallOperation::dst_extents(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.dst_extents)
  return _internal_dst_extents().Get(index);
}
inline ::chromeos_update_engine::Extent* InstallOperation::add_dst_extents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::chromeos_update_engine::Extent* _add = _internal_mutable_dst_extents()->Add();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.InstallOperation.dst_extents)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>& InstallOperation::dst_extents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.InstallOperation.dst_extents)
  return _internal_dst_extents();
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>&
InstallOperation::_internal_dst_extents() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dst_extents_;
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Extent>*
InstallOperation::_internal_mutable_dst_extents() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dst_extents_;
}

// optional uint64 dst_length = 7;
inline bool InstallOperation::has_dst_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void InstallOperation::clear_dst_length() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dst_length_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t InstallOperation::dst_length() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.dst_length)
  return _internal_dst_length();
}
inline void InstallOperation::set_dst_length(::uint64_t value) {
  _internal_set_dst_length(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.dst_length)
}
inline ::uint64_t InstallOperation::_internal_dst_length() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dst_length_;
}
inline void InstallOperation::_internal_set_dst_length(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dst_length_ = value;
}

// optional bytes data_sha256_hash = 8;
inline bool InstallOperation::has_data_sha256_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void InstallOperation::clear_data_sha256_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_sha256_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InstallOperation::data_sha256_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.data_sha256_hash)
  return _internal_data_sha256_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstallOperation::set_data_sha256_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_sha256_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.data_sha256_hash)
}
inline std::string* InstallOperation::mutable_data_sha256_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data_sha256_hash();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.data_sha256_hash)
  return _s;
}
inline const std::string& InstallOperation::_internal_data_sha256_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_sha256_hash_.Get();
}
inline void InstallOperation::_internal_set_data_sha256_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_sha256_hash_.Set(value, GetArena());
}
inline std::string* InstallOperation::_internal_mutable_data_sha256_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_sha256_hash_.Mutable( GetArena());
}
inline std::string* InstallOperation::release_data_sha256_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.InstallOperation.data_sha256_hash)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.data_sha256_hash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.data_sha256_hash_.Set("", GetArena());
  }
  return released;
}
inline void InstallOperation::set_allocated_data_sha256_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_sha256_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_sha256_hash_.IsDefault()) {
    _impl_.data_sha256_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.InstallOperation.data_sha256_hash)
}

// optional bytes src_sha256_hash = 9;
inline bool InstallOperation::has_src_sha256_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InstallOperation::clear_src_sha256_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_sha256_hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InstallOperation::src_sha256_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.src_sha256_hash)
  return _internal_src_sha256_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InstallOperation::set_src_sha256_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.src_sha256_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.src_sha256_hash)
}
inline std::string* InstallOperation::mutable_src_sha256_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_src_sha256_hash();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.src_sha256_hash)
  return _s;
}
inline const std::string& InstallOperation::_internal_src_sha256_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.src_sha256_hash_.Get();
}
inline void InstallOperation::_internal_set_src_sha256_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.src_sha256_hash_.Set(value, GetArena());
}
inline std::string* InstallOperation::_internal_mutable_src_sha256_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.src_sha256_hash_.Mutable( GetArena());
}
inline std::string* InstallOperation::release_src_sha256_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.InstallOperation.src_sha256_hash)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.src_sha256_hash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.src_sha256_hash_.Set("", GetArena());
  }
  return released;
}
inline void InstallOperation::set_allocated_src_sha256_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.src_sha256_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.src_sha256_hash_.IsDefault()) {
    _impl_.src_sha256_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.InstallOperation.src_sha256_hash)
}

// -------------------------------------------------------------------

// CowMergeOperation

// optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
inline bool CowMergeOperation::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CowMergeOperation::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::chromeos_update_engine::CowMergeOperation_Type CowMergeOperation::type() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.CowMergeOperation.type)
  return _internal_type();
}
inline void CowMergeOperation::set_type(::chromeos_update_engine::CowMergeOperation_Type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.CowMergeOperation.type)
}
inline ::chromeos_update_engine::CowMergeOperation_Type CowMergeOperation::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::chromeos_update_engine::CowMergeOperation_Type>(_impl_.type_);
}
inline void CowMergeOperation::_internal_set_type(::chromeos_update_engine::CowMergeOperation_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::chromeos_update_engine::CowMergeOperation_Type_IsValid(value));
  _impl_.type_ = value;
}

// optional .chromeos_update_engine.Extent src_extent = 2;
inline bool CowMergeOperation::has_src_extent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.src_extent_ != nullptr);
  return value;
}
inline void CowMergeOperation::clear_src_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.src_extent_ != nullptr) _impl_.src_extent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::chromeos_update_engine::Extent& CowMergeOperation::_internal_src_extent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::chromeos_update_engine::Extent* p = _impl_.src_extent_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::Extent&>(::chromeos_update_engine::_Extent_default_instance_);
}
inline const ::chromeos_update_engine::Extent& CowMergeOperation::src_extent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.CowMergeOperation.src_extent)
  return _internal_src_extent();
}
inline void CowMergeOperation::unsafe_arena_set_allocated_src_extent(::chromeos_update_engine::Extent* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.src_extent_);
  }
  _impl_.src_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.CowMergeOperation.src_extent)
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::release_src_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::chromeos_update_engine::Extent* released = _impl_.src_extent_;
  _impl_.src_extent_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::unsafe_arena_release_src_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.CowMergeOperation.src_extent)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::chromeos_update_engine::Extent* temp = _impl_.src_extent_;
  _impl_.src_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::_internal_mutable_src_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.src_extent_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::chromeos_update_engine::Extent>(GetArena());
    _impl_.src_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(p);
  }
  return _impl_.src_extent_;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::mutable_src_extent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::chromeos_update_engine::Extent* _msg = _internal_mutable_src_extent();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.CowMergeOperation.src_extent)
  return _msg;
}
inline void CowMergeOperation::set_allocated_src_extent(::chromeos_update_engine::Extent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.src_extent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.src_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(value);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.CowMergeOperation.src_extent)
}

// optional .chromeos_update_engine.Extent dst_extent = 3;
inline bool CowMergeOperation::has_dst_extent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dst_extent_ != nullptr);
  return value;
}
inline void CowMergeOperation::clear_dst_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dst_extent_ != nullptr) _impl_.dst_extent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::chromeos_update_engine::Extent& CowMergeOperation::_internal_dst_extent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::chromeos_update_engine::Extent* p = _impl_.dst_extent_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::Extent&>(::chromeos_update_engine::_Extent_default_instance_);
}
inline const ::chromeos_update_engine::Extent& CowMergeOperation::dst_extent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.CowMergeOperation.dst_extent)
  return _internal_dst_extent();
}
inline void CowMergeOperation::unsafe_arena_set_allocated_dst_extent(::chromeos_update_engine::Extent* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dst_extent_);
  }
  _impl_.dst_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.CowMergeOperation.dst_extent)
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::release_dst_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::Extent* released = _impl_.dst_extent_;
  _impl_.dst_extent_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::unsafe_arena_release_dst_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.CowMergeOperation.dst_extent)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::Extent* temp = _impl_.dst_extent_;
  _impl_.dst_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::_internal_mutable_dst_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dst_extent_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::chromeos_update_engine::Extent>(GetArena());
    _impl_.dst_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(p);
  }
  return _impl_.dst_extent_;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::mutable_dst_extent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::chromeos_update_engine::Extent* _msg = _internal_mutable_dst_extent();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.CowMergeOperation.dst_extent)
  return _msg;
}
inline void CowMergeOperation::set_allocated_dst_extent(::chromeos_update_engine::Extent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dst_extent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dst_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(value);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.CowMergeOperation.dst_extent)
}

// optional uint32 src_offset = 4;
inline bool CowMergeOperation::has_src_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CowMergeOperation::clear_src_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_offset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t CowMergeOperation::src_offset() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.CowMergeOperation.src_offset)
  return _internal_src_offset();
}
inline void CowMergeOperation::set_src_offset(::uint32_t value) {
  _internal_set_src_offset(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.CowMergeOperation.src_offset)
}
inline ::uint32_t CowMergeOperation::_internal_src_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.src_offset_;
}
inline void CowMergeOperation::_internal_set_src_offset(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.src_offset_ = value;
}

// -------------------------------------------------------------------

// PartitionUpdate

// required string partition_name = 1;
inline bool PartitionUpdate::has_partition_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PartitionUpdate::clear_partition_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partition_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PartitionUpdate::partition_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.partition_name)
  return _internal_partition_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PartitionUpdate::set_partition_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.partition_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.partition_name)
}
inline std::string* PartitionUpdate::mutable_partition_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_partition_name();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.partition_name)
  return _s;
}
inline const std::string& PartitionUpdate::_internal_partition_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.partition_name_.Get();
}
inline void PartitionUpdate::_internal_set_partition_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.partition_name_.Set(value, GetArena());
}
inline std::string* PartitionUpdate::_internal_mutable_partition_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.partition_name_.Mutable( GetArena());
}
inline std::string* PartitionUpdate::release_partition_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.partition_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.partition_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.partition_name_.Set("", GetArena());
  }
  return released;
}
inline void PartitionUpdate::set_allocated_partition_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.partition_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.partition_name_.IsDefault()) {
    _impl_.partition_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.partition_name)
}

// optional bool run_postinstall = 2;
inline bool PartitionUpdate::has_run_postinstall() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void PartitionUpdate::clear_run_postinstall() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.run_postinstall_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool PartitionUpdate::run_postinstall() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.run_postinstall)
  return _internal_run_postinstall();
}
inline void PartitionUpdate::set_run_postinstall(bool value) {
  _internal_set_run_postinstall(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.run_postinstall)
}
inline bool PartitionUpdate::_internal_run_postinstall() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.run_postinstall_;
}
inline void PartitionUpdate::_internal_set_run_postinstall(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.run_postinstall_ = value;
}

// optional string postinstall_path = 3;
inline bool PartitionUpdate::has_postinstall_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PartitionUpdate::clear_postinstall_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.postinstall_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PartitionUpdate::postinstall_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.postinstall_path)
  return _internal_postinstall_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PartitionUpdate::set_postinstall_path(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.postinstall_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.postinstall_path)
}
inline std::string* PartitionUpdate::mutable_postinstall_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_postinstall_path();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.postinstall_path)
  return _s;
}
inline const std::string& PartitionUpdate::_internal_postinstall_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.postinstall_path_.Get();
}
inline void PartitionUpdate::_internal_set_postinstall_path(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.postinstall_path_.Set(value, GetArena());
}
inline std::string* PartitionUpdate::_internal_mutable_postinstall_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.postinstall_path_.Mutable( GetArena());
}
inline std::string* PartitionUpdate::release_postinstall_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.postinstall_path)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.postinstall_path_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.postinstall_path_.Set("", GetArena());
  }
  return released;
}
inline void PartitionUpdate::set_allocated_postinstall_path(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.postinstall_path_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.postinstall_path_.IsDefault()) {
    _impl_.postinstall_path_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.postinstall_path)
}

// optional string filesystem_type = 4;
inline bool PartitionUpdate::has_filesystem_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PartitionUpdate::clear_filesystem_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filesystem_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PartitionUpdate::filesystem_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.filesystem_type)
  return _internal_filesystem_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PartitionUpdate::set_filesystem_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.filesystem_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.filesystem_type)
}
inline std::string* PartitionUpdate::mutable_filesystem_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filesystem_type();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.filesystem_type)
  return _s;
}
inline const std::string& PartitionUpdate::_internal_filesystem_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filesystem_type_.Get();
}
inline void PartitionUpdate::_internal_set_filesystem_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.filesystem_type_.Set(value, GetArena());
}
inline std::string* PartitionUpdate::_internal_mutable_filesystem_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.filesystem_type_.Mutable( GetArena());
}
inline std::string* PartitionUpdate::release_filesystem_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.filesystem_type)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.filesystem_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.filesystem_type_.Set("", GetArena());
  }
  return released;
}
inline void PartitionUpdate::set_allocated_filesystem_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.filesystem_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.filesystem_type_.IsDefault()) {
    _impl_.filesystem_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.filesystem_type)
}

// repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
inline int PartitionUpdate::_internal_new_partition_signature_size() const {
  return _internal_new_partition_signature().size();
}
inline int PartitionUpdate::new_partition_signature_size() const {
  return _internal_new_partition_signature_size();
}
inline void PartitionUpdate::clear_new_partition_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_partition_signature_.Clear();
}
inline ::chromeos_update_engine::Signatures_Signature* PartitionUpdate::mutable_new_partition_signature(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return _internal_mutable_new_partition_signature()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>* PartitionUpdate::mutable_new_partition_signature()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_new_partition_signature();
}
inline const ::chromeos_update_engine::Signatures_Signature& PartitionUpdate::new_partition_signature(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return _internal_new_partition_signature().Get(index);
}
inline ::chromeos_update_engine::Signatures_Signature* PartitionUpdate::add_new_partition_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::chromeos_update_engine::Signatures_Signature* _add = _internal_mutable_new_partition_signature()->Add();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>& PartitionUpdate::new_partition_signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return _internal_new_partition_signature();
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>&
PartitionUpdate::_internal_new_partition_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_partition_signature_;
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::Signatures_Signature>*
PartitionUpdate::_internal_mutable_new_partition_signature() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.new_partition_signature_;
}

// optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
inline bool PartitionUpdate::has_old_partition_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.old_partition_info_ != nullptr);
  return value;
}
inline void PartitionUpdate::clear_old_partition_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.old_partition_info_ != nullptr) _impl_.old_partition_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::chromeos_update_engine::PartitionInfo& PartitionUpdate::_internal_old_partition_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::chromeos_update_engine::PartitionInfo* p = _impl_.old_partition_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::PartitionInfo&>(::chromeos_update_engine::_PartitionInfo_default_instance_);
}
inline const ::chromeos_update_engine::PartitionInfo& PartitionUpdate::old_partition_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.old_partition_info)
  return _internal_old_partition_info();
}
inline void PartitionUpdate::unsafe_arena_set_allocated_old_partition_info(::chromeos_update_engine::PartitionInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.old_partition_info_);
  }
  _impl_.old_partition_info_ = reinterpret_cast<::chromeos_update_engine::PartitionInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.PartitionUpdate.old_partition_info)
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::release_old_partition_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::chromeos_update_engine::PartitionInfo* released = _impl_.old_partition_info_;
  _impl_.old_partition_info_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::unsafe_arena_release_old_partition_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.old_partition_info)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::chromeos_update_engine::PartitionInfo* temp = _impl_.old_partition_info_;
  _impl_.old_partition_info_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::_internal_mutable_old_partition_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.old_partition_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::chromeos_update_engine::PartitionInfo>(GetArena());
    _impl_.old_partition_info_ = reinterpret_cast<::chromeos_update_engine::PartitionInfo*>(p);
  }
  return _impl_.old_partition_info_;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::mutable_old_partition_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::chromeos_update_engine::PartitionInfo* _msg = _internal_mutable_old_partition_info();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.old_partition_info)
  return _msg;
}
inline void PartitionUpdate::set_allocated_old_partition_info(::chromeos_update_engine::PartitionInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.old_partition_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.old_partition_info_ = reinterpret_cast<::chromeos_update_engine::PartitionInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.old_partition_info)
}

// optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
inline bool PartitionUpdate::has_new_partition_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.new_partition_info_ != nullptr);
  return value;
}
inline void PartitionUpdate::clear_new_partition_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.new_partition_info_ != nullptr) _impl_.new_partition_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::chromeos_update_engine::PartitionInfo& PartitionUpdate::_internal_new_partition_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::chromeos_update_engine::PartitionInfo* p = _impl_.new_partition_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::PartitionInfo&>(::chromeos_update_engine::_PartitionInfo_default_instance_);
}
inline const ::chromeos_update_engine::PartitionInfo& PartitionUpdate::new_partition_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.new_partition_info)
  return _internal_new_partition_info();
}
inline void PartitionUpdate::unsafe_arena_set_allocated_new_partition_info(::chromeos_update_engine::PartitionInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.new_partition_info_);
  }
  _impl_.new_partition_info_ = reinterpret_cast<::chromeos_update_engine::PartitionInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.PartitionUpdate.new_partition_info)
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::release_new_partition_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::chromeos_update_engine::PartitionInfo* released = _impl_.new_partition_info_;
  _impl_.new_partition_info_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::unsafe_arena_release_new_partition_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.new_partition_info)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::chromeos_update_engine::PartitionInfo* temp = _impl_.new_partition_info_;
  _impl_.new_partition_info_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::_internal_mutable_new_partition_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.new_partition_info_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::chromeos_update_engine::PartitionInfo>(GetArena());
    _impl_.new_partition_info_ = reinterpret_cast<::chromeos_update_engine::PartitionInfo*>(p);
  }
  return _impl_.new_partition_info_;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::mutable_new_partition_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::chromeos_update_engine::PartitionInfo* _msg = _internal_mutable_new_partition_info();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.new_partition_info)
  return _msg;
}
inline void PartitionUpdate::set_allocated_new_partition_info(::chromeos_update_engine::PartitionInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.new_partition_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.new_partition_info_ = reinterpret_cast<::chromeos_update_engine::PartitionInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.new_partition_info)
}

// repeated .chromeos_update_engine.InstallOperation operations = 8;
inline int PartitionUpdate::_internal_operations_size() const {
  return _internal_operations().size();
}
inline int PartitionUpdate::operations_size() const {
  return _internal_operations_size();
}
inline void PartitionUpdate::clear_operations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.operations_.Clear();
}
inline ::chromeos_update_engine::InstallOperation* PartitionUpdate::mutable_operations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.operations)
  return _internal_mutable_operations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::InstallOperation>* PartitionUpdate::mutable_operations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.PartitionUpdate.operations)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_operations();
}
inline const ::chromeos_update_engine::InstallOperation& PartitionUpdate::operations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.operations)
  return _internal_operations().Get(index);
}
inline ::chromeos_update_engine::InstallOperation* PartitionUpdate::add_operations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::chromeos_update_engine::InstallOperation* _add = _internal_mutable_operations()->Add();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.PartitionUpdate.operations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::InstallOperation>& PartitionUpdate::operations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.PartitionUpdate.operations)
  return _internal_operations();
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::InstallOperation>&
PartitionUpdate::_internal_operations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.operations_;
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::InstallOperation>*
PartitionUpdate::_internal_mutable_operations() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.operations_;
}

// optional bool postinstall_optional = 9;
inline bool PartitionUpdate::has_postinstall_optional() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void PartitionUpdate::clear_postinstall_optional() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.postinstall_optional_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool PartitionUpdate::postinstall_optional() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.postinstall_optional)
  return _internal_postinstall_optional();
}
inline void PartitionUpdate::set_postinstall_optional(bool value) {
  _internal_set_postinstall_optional(value);
  _impl_._has_bits_[0] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.postinstall_optional)
}
inline bool PartitionUpdate::_internal_postinstall_optional() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.postinstall_optional_;
}
inline void PartitionUpdate::_internal_set_postinstall_optional(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.postinstall_optional_ = value;
}

// optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
inline bool PartitionUpdate::has_hash_tree_data_extent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hash_tree_data_extent_ != nullptr);
  return value;
}
inline void PartitionUpdate::clear_hash_tree_data_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hash_tree_data_extent_ != nullptr) _impl_.hash_tree_data_extent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::_internal_hash_tree_data_extent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::chromeos_update_engine::Extent* p = _impl_.hash_tree_data_extent_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::Extent&>(::chromeos_update_engine::_Extent_default_instance_);
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::hash_tree_data_extent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
  return _internal_hash_tree_data_extent();
}
inline void PartitionUpdate::unsafe_arena_set_allocated_hash_tree_data_extent(::chromeos_update_engine::Extent* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hash_tree_data_extent_);
  }
  _impl_.hash_tree_data_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_hash_tree_data_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::chromeos_update_engine::Extent* released = _impl_.hash_tree_data_extent_;
  _impl_.hash_tree_data_extent_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::unsafe_arena_release_hash_tree_data_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::chromeos_update_engine::Extent* temp = _impl_.hash_tree_data_extent_;
  _impl_.hash_tree_data_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::_internal_mutable_hash_tree_data_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hash_tree_data_extent_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::chromeos_update_engine::Extent>(GetArena());
    _impl_.hash_tree_data_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(p);
  }
  return _impl_.hash_tree_data_extent_;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_hash_tree_data_extent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::chromeos_update_engine::Extent* _msg = _internal_mutable_hash_tree_data_extent();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
  return _msg;
}
inline void PartitionUpdate::set_allocated_hash_tree_data_extent(::chromeos_update_engine::Extent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.hash_tree_data_extent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.hash_tree_data_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(value);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
}

// optional .chromeos_update_engine.Extent hash_tree_extent = 11;
inline bool PartitionUpdate::has_hash_tree_extent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hash_tree_extent_ != nullptr);
  return value;
}
inline void PartitionUpdate::clear_hash_tree_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hash_tree_extent_ != nullptr) _impl_.hash_tree_extent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::_internal_hash_tree_extent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::chromeos_update_engine::Extent* p = _impl_.hash_tree_extent_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::Extent&>(::chromeos_update_engine::_Extent_default_instance_);
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::hash_tree_extent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
  return _internal_hash_tree_extent();
}
inline void PartitionUpdate::unsafe_arena_set_allocated_hash_tree_extent(::chromeos_update_engine::Extent* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hash_tree_extent_);
  }
  _impl_.hash_tree_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_hash_tree_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::chromeos_update_engine::Extent* released = _impl_.hash_tree_extent_;
  _impl_.hash_tree_extent_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::unsafe_arena_release_hash_tree_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_extent)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::chromeos_update_engine::Extent* temp = _impl_.hash_tree_extent_;
  _impl_.hash_tree_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::_internal_mutable_hash_tree_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hash_tree_extent_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::chromeos_update_engine::Extent>(GetArena());
    _impl_.hash_tree_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(p);
  }
  return _impl_.hash_tree_extent_;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_hash_tree_extent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::chromeos_update_engine::Extent* _msg = _internal_mutable_hash_tree_extent();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
  return _msg;
}
inline void PartitionUpdate::set_allocated_hash_tree_extent(::chromeos_update_engine::Extent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.hash_tree_extent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.hash_tree_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(value);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
}

// optional string hash_tree_algorithm = 12;
inline bool PartitionUpdate::has_hash_tree_algorithm() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PartitionUpdate::clear_hash_tree_algorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_tree_algorithm_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PartitionUpdate::hash_tree_algorithm() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
  return _internal_hash_tree_algorithm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PartitionUpdate::set_hash_tree_algorithm(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.hash_tree_algorithm_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
}
inline std::string* PartitionUpdate::mutable_hash_tree_algorithm() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hash_tree_algorithm();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
  return _s;
}
inline const std::string& PartitionUpdate::_internal_hash_tree_algorithm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash_tree_algorithm_.Get();
}
inline void PartitionUpdate::_internal_set_hash_tree_algorithm(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.hash_tree_algorithm_.Set(value, GetArena());
}
inline std::string* PartitionUpdate::_internal_mutable_hash_tree_algorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.hash_tree_algorithm_.Mutable( GetArena());
}
inline std::string* PartitionUpdate::release_hash_tree_algorithm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.hash_tree_algorithm_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.hash_tree_algorithm_.Set("", GetArena());
  }
  return released;
}
inline void PartitionUpdate::set_allocated_hash_tree_algorithm(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.hash_tree_algorithm_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hash_tree_algorithm_.IsDefault()) {
    _impl_.hash_tree_algorithm_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
}

// optional bytes hash_tree_salt = 13;
inline bool PartitionUpdate::has_hash_tree_salt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PartitionUpdate::clear_hash_tree_salt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_tree_salt_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PartitionUpdate::hash_tree_salt() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
  return _internal_hash_tree_salt();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PartitionUpdate::set_hash_tree_salt(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.hash_tree_salt_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
}
inline std::string* PartitionUpdate::mutable_hash_tree_salt() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hash_tree_salt();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
  return _s;
}
inline const std::string& PartitionUpdate::_internal_hash_tree_salt() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash_tree_salt_.Get();
}
inline void PartitionUpdate::_internal_set_hash_tree_salt(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.hash_tree_salt_.Set(value, GetArena());
}
inline std::string* PartitionUpdate::_internal_mutable_hash_tree_salt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.hash_tree_salt_.Mutable( GetArena());
}
inline std::string* PartitionUpdate::release_hash_tree_salt() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.hash_tree_salt_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.hash_tree_salt_.Set("", GetArena());
  }
  return released;
}
inline void PartitionUpdate::set_allocated_hash_tree_salt(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.hash_tree_salt_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hash_tree_salt_.IsDefault()) {
    _impl_.hash_tree_salt_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
}

// optional .chromeos_update_engine.Extent fec_data_extent = 14;
inline bool PartitionUpdate::has_fec_data_extent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fec_data_extent_ != nullptr);
  return value;
}
inline void PartitionUpdate::clear_fec_data_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fec_data_extent_ != nullptr) _impl_.fec_data_extent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::_internal_fec_data_extent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::chromeos_update_engine::Extent* p = _impl_.fec_data_extent_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::Extent&>(::chromeos_update_engine::_Extent_default_instance_);
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::fec_data_extent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.fec_data_extent)
  return _internal_fec_data_extent();
}
inline void PartitionUpdate::unsafe_arena_set_allocated_fec_data_extent(::chromeos_update_engine::Extent* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fec_data_extent_);
  }
  _impl_.fec_data_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.PartitionUpdate.fec_data_extent)
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_fec_data_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::chromeos_update_engine::Extent* released = _impl_.fec_data_extent_;
  _impl_.fec_data_extent_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::unsafe_arena_release_fec_data_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.fec_data_extent)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::chromeos_update_engine::Extent* temp = _impl_.fec_data_extent_;
  _impl_.fec_data_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::_internal_mutable_fec_data_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fec_data_extent_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::chromeos_update_engine::Extent>(GetArena());
    _impl_.fec_data_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(p);
  }
  return _impl_.fec_data_extent_;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_fec_data_extent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000400u;
  ::chromeos_update_engine::Extent* _msg = _internal_mutable_fec_data_extent();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.fec_data_extent)
  return _msg;
}
inline void PartitionUpdate::set_allocated_fec_data_extent(::chromeos_update_engine::Extent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.fec_data_extent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.fec_data_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(value);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.fec_data_extent)
}

// optional .chromeos_update_engine.Extent fec_extent = 15;
inline bool PartitionUpdate::has_fec_extent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.fec_extent_ != nullptr);
  return value;
}
inline void PartitionUpdate::clear_fec_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fec_extent_ != nullptr) _impl_.fec_extent_->Clear();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::_internal_fec_extent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::chromeos_update_engine::Extent* p = _impl_.fec_extent_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::Extent&>(::chromeos_update_engine::_Extent_default_instance_);
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::fec_extent() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.fec_extent)
  return _internal_fec_extent();
}
inline void PartitionUpdate::unsafe_arena_set_allocated_fec_extent(::chromeos_update_engine::Extent* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.fec_extent_);
  }
  _impl_.fec_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.PartitionUpdate.fec_extent)
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_fec_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::chromeos_update_engine::Extent* released = _impl_.fec_extent_;
  _impl_.fec_extent_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::unsafe_arena_release_fec_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.fec_extent)

  _impl_._has_bits_[0] &= ~0x00000800u;
  ::chromeos_update_engine::Extent* temp = _impl_.fec_extent_;
  _impl_.fec_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::_internal_mutable_fec_extent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.fec_extent_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::chromeos_update_engine::Extent>(GetArena());
    _impl_.fec_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(p);
  }
  return _impl_.fec_extent_;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_fec_extent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000800u;
  ::chromeos_update_engine::Extent* _msg = _internal_mutable_fec_extent();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.fec_extent)
  return _msg;
}
inline void PartitionUpdate::set_allocated_fec_extent(::chromeos_update_engine::Extent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.fec_extent_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }

  _impl_.fec_extent_ = reinterpret_cast<::chromeos_update_engine::Extent*>(value);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.fec_extent)
}

// optional uint32 fec_roots = 16 [default = 2];
inline bool PartitionUpdate::has_fec_roots() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void PartitionUpdate::clear_fec_roots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fec_roots_ = 2u;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::uint32_t PartitionUpdate::fec_roots() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.fec_roots)
  return _internal_fec_roots();
}
inline void PartitionUpdate::set_fec_roots(::uint32_t value) {
  _internal_set_fec_roots(value);
  _impl_._has_bits_[0] |= 0x00010000u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.fec_roots)
}
inline ::uint32_t PartitionUpdate::_internal_fec_roots() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fec_roots_;
}
inline void PartitionUpdate::_internal_set_fec_roots(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fec_roots_ = value;
}

// optional string version = 17;
inline bool PartitionUpdate::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void PartitionUpdate::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& PartitionUpdate::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PartitionUpdate::set_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.version)
}
inline std::string* PartitionUpdate::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.version)
  return _s;
}
inline const std::string& PartitionUpdate::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_.Get();
}
inline void PartitionUpdate::_internal_set_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.version_.Set(value, GetArena());
}
inline std::string* PartitionUpdate::_internal_mutable_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* PartitionUpdate::release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.version)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.version_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.version_.Set("", GetArena());
  }
  return released;
}
inline void PartitionUpdate::set_allocated_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.version)
}

// repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
inline int PartitionUpdate::_internal_merge_operations_size() const {
  return _internal_merge_operations().size();
}
inline int PartitionUpdate::merge_operations_size() const {
  return _internal_merge_operations_size();
}
inline void PartitionUpdate::clear_merge_operations() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.merge_operations_.Clear();
}
inline ::chromeos_update_engine::CowMergeOperation* PartitionUpdate::mutable_merge_operations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.merge_operations)
  return _internal_mutable_merge_operations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::CowMergeOperation>* PartitionUpdate::mutable_merge_operations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.PartitionUpdate.merge_operations)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_merge_operations();
}
inline const ::chromeos_update_engine::CowMergeOperation& PartitionUpdate::merge_operations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.merge_operations)
  return _internal_merge_operations().Get(index);
}
inline ::chromeos_update_engine::CowMergeOperation* PartitionUpdate::add_merge_operations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::chromeos_update_engine::CowMergeOperation* _add = _internal_mutable_merge_operations()->Add();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.PartitionUpdate.merge_operations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::CowMergeOperation>& PartitionUpdate::merge_operations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.PartitionUpdate.merge_operations)
  return _internal_merge_operations();
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::CowMergeOperation>&
PartitionUpdate::_internal_merge_operations() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.merge_operations_;
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::CowMergeOperation>*
PartitionUpdate::_internal_mutable_merge_operations() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.merge_operations_;
}

// optional uint64 estimate_cow_size = 19;
inline bool PartitionUpdate::has_estimate_cow_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void PartitionUpdate::clear_estimate_cow_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.estimate_cow_size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::uint64_t PartitionUpdate::estimate_cow_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.estimate_cow_size)
  return _internal_estimate_cow_size();
}
inline void PartitionUpdate::set_estimate_cow_size(::uint64_t value) {
  _internal_set_estimate_cow_size(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.estimate_cow_size)
}
inline ::uint64_t PartitionUpdate::_internal_estimate_cow_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.estimate_cow_size_;
}
inline void PartitionUpdate::_internal_set_estimate_cow_size(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.estimate_cow_size_ = value;
}

// optional uint64 estimate_op_count_max = 20;
inline bool PartitionUpdate::has_estimate_op_count_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void PartitionUpdate::clear_estimate_op_count_max() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.estimate_op_count_max_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::uint64_t PartitionUpdate::estimate_op_count_max() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.estimate_op_count_max)
  return _internal_estimate_op_count_max();
}
inline void PartitionUpdate::set_estimate_op_count_max(::uint64_t value) {
  _internal_set_estimate_op_count_max(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.estimate_op_count_max)
}
inline ::uint64_t PartitionUpdate::_internal_estimate_op_count_max() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.estimate_op_count_max_;
}
inline void PartitionUpdate::_internal_set_estimate_op_count_max(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.estimate_op_count_max_ = value;
}

// -------------------------------------------------------------------

// DynamicPartitionGroup

// required string name = 1;
inline bool DynamicPartitionGroup::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DynamicPartitionGroup::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DynamicPartitionGroup::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionGroup.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DynamicPartitionGroup::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionGroup.name)
}
inline std::string* DynamicPartitionGroup::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionGroup.name)
  return _s;
}
inline const std::string& DynamicPartitionGroup::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void DynamicPartitionGroup::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* DynamicPartitionGroup::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* DynamicPartitionGroup::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DynamicPartitionGroup.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void DynamicPartitionGroup::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DynamicPartitionGroup.name)
}

// optional uint64 size = 2;
inline bool DynamicPartitionGroup::has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DynamicPartitionGroup::clear_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t DynamicPartitionGroup::size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionGroup.size)
  return _internal_size();
}
inline void DynamicPartitionGroup::set_size(::uint64_t value) {
  _internal_set_size(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionGroup.size)
}
inline ::uint64_t DynamicPartitionGroup::_internal_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.size_;
}
inline void DynamicPartitionGroup::_internal_set_size(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.size_ = value;
}

// repeated string partition_names = 3;
inline int DynamicPartitionGroup::_internal_partition_names_size() const {
  return _internal_partition_names().size();
}
inline int DynamicPartitionGroup::partition_names_size() const {
  return _internal_partition_names_size();
}
inline void DynamicPartitionGroup::clear_partition_names() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partition_names_.Clear();
}
inline std::string* DynamicPartitionGroup::add_partition_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_partition_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return _s;
}
inline const std::string& DynamicPartitionGroup::partition_names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return _internal_partition_names().Get(index);
}
inline std::string* DynamicPartitionGroup::mutable_partition_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return _internal_mutable_partition_names()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void DynamicPartitionGroup::set_partition_names(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_partition_names()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
template <typename Arg_, typename... Args_>
inline void DynamicPartitionGroup::add_partition_names(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_partition_names(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DynamicPartitionGroup::partition_names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return _internal_partition_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DynamicPartitionGroup::mutable_partition_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_partition_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DynamicPartitionGroup::_internal_partition_names() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.partition_names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DynamicPartitionGroup::_internal_mutable_partition_names() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.partition_names_;
}

// -------------------------------------------------------------------

// VABCFeatureSet

// optional bool threaded = 1;
inline bool VABCFeatureSet::has_threaded() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VABCFeatureSet::clear_threaded() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threaded_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool VABCFeatureSet::threaded() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.VABCFeatureSet.threaded)
  return _internal_threaded();
}
inline void VABCFeatureSet::set_threaded(bool value) {
  _internal_set_threaded(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.VABCFeatureSet.threaded)
}
inline bool VABCFeatureSet::_internal_threaded() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.threaded_;
}
inline void VABCFeatureSet::_internal_set_threaded(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threaded_ = value;
}

// optional bool batch_writes = 2;
inline bool VABCFeatureSet::has_batch_writes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VABCFeatureSet::clear_batch_writes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.batch_writes_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool VABCFeatureSet::batch_writes() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.VABCFeatureSet.batch_writes)
  return _internal_batch_writes();
}
inline void VABCFeatureSet::set_batch_writes(bool value) {
  _internal_set_batch_writes(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.VABCFeatureSet.batch_writes)
}
inline bool VABCFeatureSet::_internal_batch_writes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.batch_writes_;
}
inline void VABCFeatureSet::_internal_set_batch_writes(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.batch_writes_ = value;
}

// -------------------------------------------------------------------

// DynamicPartitionMetadata

// repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
inline int DynamicPartitionMetadata::_internal_groups_size() const {
  return _internal_groups().size();
}
inline int DynamicPartitionMetadata::groups_size() const {
  return _internal_groups_size();
}
inline void DynamicPartitionMetadata::clear_groups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.groups_.Clear();
}
inline ::chromeos_update_engine::DynamicPartitionGroup* DynamicPartitionMetadata::mutable_groups(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return _internal_mutable_groups()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::DynamicPartitionGroup>* DynamicPartitionMetadata::mutable_groups()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DynamicPartitionMetadata.groups)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_groups();
}
inline const ::chromeos_update_engine::DynamicPartitionGroup& DynamicPartitionMetadata::groups(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return _internal_groups().Get(index);
}
inline ::chromeos_update_engine::DynamicPartitionGroup* DynamicPartitionMetadata::add_groups() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::chromeos_update_engine::DynamicPartitionGroup* _add = _internal_mutable_groups()->Add();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::DynamicPartitionGroup>& DynamicPartitionMetadata::groups() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return _internal_groups();
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::DynamicPartitionGroup>&
DynamicPartitionMetadata::_internal_groups() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.groups_;
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::DynamicPartitionGroup>*
DynamicPartitionMetadata::_internal_mutable_groups() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.groups_;
}

// optional bool snapshot_enabled = 2;
inline bool DynamicPartitionMetadata::has_snapshot_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void DynamicPartitionMetadata::clear_snapshot_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool DynamicPartitionMetadata::snapshot_enabled() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.snapshot_enabled)
  return _internal_snapshot_enabled();
}
inline void DynamicPartitionMetadata::set_snapshot_enabled(bool value) {
  _internal_set_snapshot_enabled(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.snapshot_enabled)
}
inline bool DynamicPartitionMetadata::_internal_snapshot_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.snapshot_enabled_;
}
inline void DynamicPartitionMetadata::_internal_set_snapshot_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_enabled_ = value;
}

// optional bool vabc_enabled = 3;
inline bool DynamicPartitionMetadata::has_vabc_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void DynamicPartitionMetadata::clear_vabc_enabled() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vabc_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool DynamicPartitionMetadata::vabc_enabled() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.vabc_enabled)
  return _internal_vabc_enabled();
}
inline void DynamicPartitionMetadata::set_vabc_enabled(bool value) {
  _internal_set_vabc_enabled(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.vabc_enabled)
}
inline bool DynamicPartitionMetadata::_internal_vabc_enabled() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vabc_enabled_;
}
inline void DynamicPartitionMetadata::_internal_set_vabc_enabled(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vabc_enabled_ = value;
}

// optional string vabc_compression_param = 4;
inline bool DynamicPartitionMetadata::has_vabc_compression_param() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DynamicPartitionMetadata::clear_vabc_compression_param() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.vabc_compression_param_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DynamicPartitionMetadata::vabc_compression_param() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
  return _internal_vabc_compression_param();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DynamicPartitionMetadata::set_vabc_compression_param(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vabc_compression_param_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
}
inline std::string* DynamicPartitionMetadata::mutable_vabc_compression_param() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_vabc_compression_param();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
  return _s;
}
inline const std::string& DynamicPartitionMetadata::_internal_vabc_compression_param() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.vabc_compression_param_.Get();
}
inline void DynamicPartitionMetadata::_internal_set_vabc_compression_param(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vabc_compression_param_.Set(value, GetArena());
}
inline std::string* DynamicPartitionMetadata::_internal_mutable_vabc_compression_param() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.vabc_compression_param_.Mutable( GetArena());
}
inline std::string* DynamicPartitionMetadata::release_vabc_compression_param() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.vabc_compression_param_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.vabc_compression_param_.Set("", GetArena());
  }
  return released;
}
inline void DynamicPartitionMetadata::set_allocated_vabc_compression_param(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.vabc_compression_param_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.vabc_compression_param_.IsDefault()) {
    _impl_.vabc_compression_param_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
}

// optional uint32 cow_version = 5;
inline bool DynamicPartitionMetadata::has_cow_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void DynamicPartitionMetadata::clear_cow_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cow_version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t DynamicPartitionMetadata::cow_version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.cow_version)
  return _internal_cow_version();
}
inline void DynamicPartitionMetadata::set_cow_version(::uint32_t value) {
  _internal_set_cow_version(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.cow_version)
}
inline ::uint32_t DynamicPartitionMetadata::_internal_cow_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cow_version_;
}
inline void DynamicPartitionMetadata::_internal_set_cow_version(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cow_version_ = value;
}

// optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
inline bool DynamicPartitionMetadata::has_vabc_feature_set() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vabc_feature_set_ != nullptr);
  return value;
}
inline void DynamicPartitionMetadata::clear_vabc_feature_set() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vabc_feature_set_ != nullptr) _impl_.vabc_feature_set_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::chromeos_update_engine::VABCFeatureSet& DynamicPartitionMetadata::_internal_vabc_feature_set() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::chromeos_update_engine::VABCFeatureSet* p = _impl_.vabc_feature_set_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::VABCFeatureSet&>(::chromeos_update_engine::_VABCFeatureSet_default_instance_);
}
inline const ::chromeos_update_engine::VABCFeatureSet& DynamicPartitionMetadata::vabc_feature_set() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.vabc_feature_set)
  return _internal_vabc_feature_set();
}
inline void DynamicPartitionMetadata::unsafe_arena_set_allocated_vabc_feature_set(::chromeos_update_engine::VABCFeatureSet* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vabc_feature_set_);
  }
  _impl_.vabc_feature_set_ = reinterpret_cast<::chromeos_update_engine::VABCFeatureSet*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.DynamicPartitionMetadata.vabc_feature_set)
}
inline ::chromeos_update_engine::VABCFeatureSet* DynamicPartitionMetadata::release_vabc_feature_set() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::VABCFeatureSet* released = _impl_.vabc_feature_set_;
  _impl_.vabc_feature_set_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::chromeos_update_engine::VABCFeatureSet* DynamicPartitionMetadata::unsafe_arena_release_vabc_feature_set() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DynamicPartitionMetadata.vabc_feature_set)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::VABCFeatureSet* temp = _impl_.vabc_feature_set_;
  _impl_.vabc_feature_set_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::VABCFeatureSet* DynamicPartitionMetadata::_internal_mutable_vabc_feature_set() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vabc_feature_set_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::chromeos_update_engine::VABCFeatureSet>(GetArena());
    _impl_.vabc_feature_set_ = reinterpret_cast<::chromeos_update_engine::VABCFeatureSet*>(p);
  }
  return _impl_.vabc_feature_set_;
}
inline ::chromeos_update_engine::VABCFeatureSet* DynamicPartitionMetadata::mutable_vabc_feature_set() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::chromeos_update_engine::VABCFeatureSet* _msg = _internal_mutable_vabc_feature_set();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionMetadata.vabc_feature_set)
  return _msg;
}
inline void DynamicPartitionMetadata::set_allocated_vabc_feature_set(::chromeos_update_engine::VABCFeatureSet* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.vabc_feature_set_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.vabc_feature_set_ = reinterpret_cast<::chromeos_update_engine::VABCFeatureSet*>(value);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DynamicPartitionMetadata.vabc_feature_set)
}

// optional uint64 compression_factor = 7;
inline bool DynamicPartitionMetadata::has_compression_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void DynamicPartitionMetadata::clear_compression_factor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compression_factor_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t DynamicPartitionMetadata::compression_factor() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.compression_factor)
  return _internal_compression_factor();
}
inline void DynamicPartitionMetadata::set_compression_factor(::uint64_t value) {
  _internal_set_compression_factor(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.compression_factor)
}
inline ::uint64_t DynamicPartitionMetadata::_internal_compression_factor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compression_factor_;
}
inline void DynamicPartitionMetadata::_internal_set_compression_factor(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compression_factor_ = value;
}

// -------------------------------------------------------------------

// ApexInfo

// optional string package_name = 1;
inline bool ApexInfo::has_package_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ApexInfo::clear_package_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.package_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ApexInfo::package_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.package_name)
  return _internal_package_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ApexInfo::set_package_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.package_name)
}
inline std::string* ApexInfo::mutable_package_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_package_name();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ApexInfo.package_name)
  return _s;
}
inline const std::string& ApexInfo::_internal_package_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.package_name_.Get();
}
inline void ApexInfo::_internal_set_package_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.package_name_.Set(value, GetArena());
}
inline std::string* ApexInfo::_internal_mutable_package_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.package_name_.Mutable( GetArena());
}
inline std::string* ApexInfo::release_package_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ApexInfo.package_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.package_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.package_name_.Set("", GetArena());
  }
  return released;
}
inline void ApexInfo::set_allocated_package_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.package_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.package_name_.IsDefault()) {
    _impl_.package_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ApexInfo.package_name)
}

// optional int64 version = 2;
inline bool ApexInfo::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ApexInfo::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t ApexInfo::version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.version)
  return _internal_version();
}
inline void ApexInfo::set_version(::int64_t value) {
  _internal_set_version(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.version)
}
inline ::int64_t ApexInfo::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_;
}
inline void ApexInfo::_internal_set_version(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// optional bool is_compressed = 3;
inline bool ApexInfo::has_is_compressed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ApexInfo::clear_is_compressed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_compressed_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ApexInfo::is_compressed() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.is_compressed)
  return _internal_is_compressed();
}
inline void ApexInfo::set_is_compressed(bool value) {
  _internal_set_is_compressed(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.is_compressed)
}
inline bool ApexInfo::_internal_is_compressed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_compressed_;
}
inline void ApexInfo::_internal_set_is_compressed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_compressed_ = value;
}

// optional int64 decompressed_size = 4;
inline bool ApexInfo::has_decompressed_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ApexInfo::clear_decompressed_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.decompressed_size_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t ApexInfo::decompressed_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.decompressed_size)
  return _internal_decompressed_size();
}
inline void ApexInfo::set_decompressed_size(::int64_t value) {
  _internal_set_decompressed_size(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.decompressed_size)
}
inline ::int64_t ApexInfo::_internal_decompressed_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.decompressed_size_;
}
inline void ApexInfo::_internal_set_decompressed_size(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.decompressed_size_ = value;
}

// -------------------------------------------------------------------

// ApexMetadata

// repeated .chromeos_update_engine.ApexInfo apex_info = 1;
inline int ApexMetadata::_internal_apex_info_size() const {
  return _internal_apex_info().size();
}
inline int ApexMetadata::apex_info_size() const {
  return _internal_apex_info_size();
}
inline void ApexMetadata::clear_apex_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.apex_info_.Clear();
}
inline ::chromeos_update_engine::ApexInfo* ApexMetadata::mutable_apex_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ApexMetadata.apex_info)
  return _internal_mutable_apex_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>* ApexMetadata::mutable_apex_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.ApexMetadata.apex_info)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_apex_info();
}
inline const ::chromeos_update_engine::ApexInfo& ApexMetadata::apex_info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexMetadata.apex_info)
  return _internal_apex_info().Get(index);
}
inline ::chromeos_update_engine::ApexInfo* ApexMetadata::add_apex_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::chromeos_update_engine::ApexInfo* _add = _internal_mutable_apex_info()->Add();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.ApexMetadata.apex_info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>& ApexMetadata::apex_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.ApexMetadata.apex_info)
  return _internal_apex_info();
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>&
ApexMetadata::_internal_apex_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.apex_info_;
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>*
ApexMetadata::_internal_mutable_apex_info() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.apex_info_;
}

// -------------------------------------------------------------------

// DeltaArchiveManifest

// optional uint32 block_size = 3 [default = 4096];
inline bool DeltaArchiveManifest::has_block_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void DeltaArchiveManifest::clear_block_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_size_ = 4096u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t DeltaArchiveManifest::block_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.block_size)
  return _internal_block_size();
}
inline void DeltaArchiveManifest::set_block_size(::uint32_t value) {
  _internal_set_block_size(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.block_size)
}
inline ::uint32_t DeltaArchiveManifest::_internal_block_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.block_size_;
}
inline void DeltaArchiveManifest::_internal_set_block_size(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.block_size_ = value;
}

// optional uint64 signatures_offset = 4;
inline bool DeltaArchiveManifest::has_signatures_offset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void DeltaArchiveManifest::clear_signatures_offset() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signatures_offset_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t DeltaArchiveManifest::signatures_offset() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.signatures_offset)
  return _internal_signatures_offset();
}
inline void DeltaArchiveManifest::set_signatures_offset(::uint64_t value) {
  _internal_set_signatures_offset(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.signatures_offset)
}
inline ::uint64_t DeltaArchiveManifest::_internal_signatures_offset() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signatures_offset_;
}
inline void DeltaArchiveManifest::_internal_set_signatures_offset(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signatures_offset_ = value;
}

// optional uint64 signatures_size = 5;
inline bool DeltaArchiveManifest::has_signatures_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void DeltaArchiveManifest::clear_signatures_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signatures_size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t DeltaArchiveManifest::signatures_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.signatures_size)
  return _internal_signatures_size();
}
inline void DeltaArchiveManifest::set_signatures_size(::uint64_t value) {
  _internal_set_signatures_size(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.signatures_size)
}
inline ::uint64_t DeltaArchiveManifest::_internal_signatures_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signatures_size_;
}
inline void DeltaArchiveManifest::_internal_set_signatures_size(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signatures_size_ = value;
}

// optional uint32 minor_version = 12 [default = 0];
inline bool DeltaArchiveManifest::has_minor_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void DeltaArchiveManifest::clear_minor_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.minor_version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t DeltaArchiveManifest::minor_version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.minor_version)
  return _internal_minor_version();
}
inline void DeltaArchiveManifest::set_minor_version(::uint32_t value) {
  _internal_set_minor_version(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.minor_version)
}
inline ::uint32_t DeltaArchiveManifest::_internal_minor_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.minor_version_;
}
inline void DeltaArchiveManifest::_internal_set_minor_version(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.minor_version_ = value;
}

// repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
inline int DeltaArchiveManifest::_internal_partitions_size() const {
  return _internal_partitions().size();
}
inline int DeltaArchiveManifest::partitions_size() const {
  return _internal_partitions_size();
}
inline void DeltaArchiveManifest::clear_partitions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partitions_.Clear();
}
inline ::chromeos_update_engine::PartitionUpdate* DeltaArchiveManifest::mutable_partitions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return _internal_mutable_partitions()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::PartitionUpdate>* DeltaArchiveManifest::mutable_partitions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DeltaArchiveManifest.partitions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_partitions();
}
inline const ::chromeos_update_engine::PartitionUpdate& DeltaArchiveManifest::partitions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return _internal_partitions().Get(index);
}
inline ::chromeos_update_engine::PartitionUpdate* DeltaArchiveManifest::add_partitions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::chromeos_update_engine::PartitionUpdate* _add = _internal_mutable_partitions()->Add();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::PartitionUpdate>& DeltaArchiveManifest::partitions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return _internal_partitions();
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::PartitionUpdate>&
DeltaArchiveManifest::_internal_partitions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.partitions_;
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::PartitionUpdate>*
DeltaArchiveManifest::_internal_mutable_partitions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.partitions_;
}

// optional int64 max_timestamp = 14;
inline bool DeltaArchiveManifest::has_max_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void DeltaArchiveManifest::clear_max_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_timestamp_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t DeltaArchiveManifest::max_timestamp() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.max_timestamp)
  return _internal_max_timestamp();
}
inline void DeltaArchiveManifest::set_max_timestamp(::int64_t value) {
  _internal_set_max_timestamp(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.max_timestamp)
}
inline ::int64_t DeltaArchiveManifest::_internal_max_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_timestamp_;
}
inline void DeltaArchiveManifest::_internal_set_max_timestamp(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_timestamp_ = value;
}

// optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
inline bool DeltaArchiveManifest::has_dynamic_partition_metadata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dynamic_partition_metadata_ != nullptr);
  return value;
}
inline void DeltaArchiveManifest::clear_dynamic_partition_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dynamic_partition_metadata_ != nullptr) _impl_.dynamic_partition_metadata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::chromeos_update_engine::DynamicPartitionMetadata& DeltaArchiveManifest::_internal_dynamic_partition_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::chromeos_update_engine::DynamicPartitionMetadata* p = _impl_.dynamic_partition_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::chromeos_update_engine::DynamicPartitionMetadata&>(::chromeos_update_engine::_DynamicPartitionMetadata_default_instance_);
}
inline const ::chromeos_update_engine::DynamicPartitionMetadata& DeltaArchiveManifest::dynamic_partition_metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
  return _internal_dynamic_partition_metadata();
}
inline void DeltaArchiveManifest::unsafe_arena_set_allocated_dynamic_partition_metadata(::chromeos_update_engine::DynamicPartitionMetadata* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dynamic_partition_metadata_);
  }
  _impl_.dynamic_partition_metadata_ = reinterpret_cast<::chromeos_update_engine::DynamicPartitionMetadata*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
}
inline ::chromeos_update_engine::DynamicPartitionMetadata* DeltaArchiveManifest::release_dynamic_partition_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::DynamicPartitionMetadata* released = _impl_.dynamic_partition_metadata_;
  _impl_.dynamic_partition_metadata_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::chromeos_update_engine::DynamicPartitionMetadata* DeltaArchiveManifest::unsafe_arena_release_dynamic_partition_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::DynamicPartitionMetadata* temp = _impl_.dynamic_partition_metadata_;
  _impl_.dynamic_partition_metadata_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::DynamicPartitionMetadata* DeltaArchiveManifest::_internal_mutable_dynamic_partition_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.dynamic_partition_metadata_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::chromeos_update_engine::DynamicPartitionMetadata>(GetArena());
    _impl_.dynamic_partition_metadata_ = reinterpret_cast<::chromeos_update_engine::DynamicPartitionMetadata*>(p);
  }
  return _impl_.dynamic_partition_metadata_;
}
inline ::chromeos_update_engine::DynamicPartitionMetadata* DeltaArchiveManifest::mutable_dynamic_partition_metadata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::chromeos_update_engine::DynamicPartitionMetadata* _msg = _internal_mutable_dynamic_partition_metadata();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
  return _msg;
}
inline void DeltaArchiveManifest::set_allocated_dynamic_partition_metadata(::chromeos_update_engine::DynamicPartitionMetadata* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.dynamic_partition_metadata_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dynamic_partition_metadata_ = reinterpret_cast<::chromeos_update_engine::DynamicPartitionMetadata*>(value);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
}

// optional bool partial_update = 16;
inline bool DeltaArchiveManifest::has_partial_update() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void DeltaArchiveManifest::clear_partial_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partial_update_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool DeltaArchiveManifest::partial_update() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.partial_update)
  return _internal_partial_update();
}
inline void DeltaArchiveManifest::set_partial_update(bool value) {
  _internal_set_partial_update(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.partial_update)
}
inline bool DeltaArchiveManifest::_internal_partial_update() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.partial_update_;
}
inline void DeltaArchiveManifest::_internal_set_partial_update(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.partial_update_ = value;
}

// repeated .chromeos_update_engine.ApexInfo apex_info = 17;
inline int DeltaArchiveManifest::_internal_apex_info_size() const {
  return _internal_apex_info().size();
}
inline int DeltaArchiveManifest::apex_info_size() const {
  return _internal_apex_info_size();
}
inline void DeltaArchiveManifest::clear_apex_info() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.apex_info_.Clear();
}
inline ::chromeos_update_engine::ApexInfo* DeltaArchiveManifest::mutable_apex_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return _internal_mutable_apex_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>* DeltaArchiveManifest::mutable_apex_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_apex_info();
}
inline const ::chromeos_update_engine::ApexInfo& DeltaArchiveManifest::apex_info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return _internal_apex_info().Get(index);
}
inline ::chromeos_update_engine::ApexInfo* DeltaArchiveManifest::add_apex_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::chromeos_update_engine::ApexInfo* _add = _internal_mutable_apex_info()->Add();
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>& DeltaArchiveManifest::apex_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return _internal_apex_info();
}
inline const ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>&
DeltaArchiveManifest::_internal_apex_info() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.apex_info_;
}
inline ::google::protobuf::RepeatedPtrField<::chromeos_update_engine::ApexInfo>*
DeltaArchiveManifest::_internal_mutable_apex_info() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.apex_info_;
}

// optional string security_patch_level = 18;
inline bool DeltaArchiveManifest::has_security_patch_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DeltaArchiveManifest::clear_security_patch_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.security_patch_level_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeltaArchiveManifest::security_patch_level() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
  return _internal_security_patch_level();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeltaArchiveManifest::set_security_patch_level(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.security_patch_level_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
}
inline std::string* DeltaArchiveManifest::mutable_security_patch_level() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_security_patch_level();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
  return _s;
}
inline const std::string& DeltaArchiveManifest::_internal_security_patch_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.security_patch_level_.Get();
}
inline void DeltaArchiveManifest::_internal_set_security_patch_level(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.security_patch_level_.Set(value, GetArena());
}
inline std::string* DeltaArchiveManifest::_internal_mutable_security_patch_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.security_patch_level_.Mutable( GetArena());
}
inline std::string* DeltaArchiveManifest::release_security_patch_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.security_patch_level_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.security_patch_level_.Set("", GetArena());
  }
  return released;
}
inline void DeltaArchiveManifest::set_allocated_security_patch_level(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.security_patch_level_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.security_patch_level_.IsDefault()) {
    _impl_.security_patch_level_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace chromeos_update_engine


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::chromeos_update_engine::InstallOperation_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::chromeos_update_engine::InstallOperation_Type>() {
  return ::chromeos_update_engine::InstallOperation_Type_descriptor();
}
template <>
struct is_proto_enum<::chromeos_update_engine::CowMergeOperation_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::chromeos_update_engine::CowMergeOperation_Type>() {
  return ::chromeos_update_engine::CowMergeOperation_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // update_5fmetadata_2eproto_2epb_2eh
